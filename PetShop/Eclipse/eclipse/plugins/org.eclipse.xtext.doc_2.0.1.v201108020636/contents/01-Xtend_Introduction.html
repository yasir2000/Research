<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Xtend</title>

<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="index.html" title="">
</head>
<body>
<a name="Xtend"></a>
<h1>Xtend</h1>
<p>
Xtend is a statically-typed programming language which is tightly integrated with and runs on the Java Virtual Machine. 
It has its roots in the Java programming language but improves on a couple of concepts:   
</p>
<p>
<ul>
	<li>
		<em>Advanced Type Inference</em> - You rarely need to write down type signatures
	</li>
	<li>
		<em>Full support for Java Generics</em> - Including all conformance and conversion rules
	</li>
	<li>
		<em>Closures</em> - concise syntax for anonymous function literals
	</li>
	<li>
		<em>Operator overloading</em> - make your libraries even more expressive
	</li>
	<li>
		<em>Powerful switch expressions</em> - type based switching with implicit casts
	</li>
	<li>
		<em>No statements</em> - Everything is an expression
	</li>
	<li>
		<em>Template expressions</em> - with intelligent white space handling
	</li>
	<li>
		<em>Extension methods</em> - Enhance closed types with new functionality optionally injected via JSR-330
	</li>
	<li>
		<em>property access syntax</em> - shorthands for getter and setter access
	</li>
	<li>
		<em>multiple dispatch</em> aka polymorphic method invocation
	</li>
	<li>
		<em>translates to Java</em> not bytecode - understand what&apos;s going on and use your code for platforms such as Android or GWT
	</li>
</ul>
</p>
<p>
It is not aiming at replacing Java all together. Therefore its library is a thin layer over the Java Development Kit (JDK) and interacts with Java 
exactly the same as it interacts with Xtend code. Also Java can call Xtend functions in a completely transparent way. And of course, it provides a 
modern Eclipse-based IDE closely integrated with the Java Development Tools (JDT).
</p>
<a name="Getting_Started"></a>
<h2>Getting Started</h2>
<p>
The best way to get started is to materialize the <em>Xtend Tutorial</em> example project in your workspace.
You&apos;ll find it in the new project wizard dialog.
</p>
<p>
The project contains a couple of sample Xtend files, which show the different language concepts in action.
You should also have a look into the <em>xtend-gen</em> folder which contains the generated Java-version of them.
</p>
<p>
<div class="image" >
<img src="../../images/Xtend_and_Java.png" 
/>
<div class="caption">
Xtend and Java Vis-a-Vis
</div>
</div>
</p>
<a name="Xtend_Classes_Functions"></a>
<h2>Classes and Functions</h2>
<p>
On a first glance an Xtend file pretty much looks like a Java file. It starts with a package declaration followed by an import section, and after that comes the class definition.
That class in fact is directly translated to a Java class in the corresponding Java package.
</p>
<p>
Here is an example:
<div class="literallayout">
<div class="incode">
<p class="code">
package&nbsp;com.acme<br/>
<br/>
<span class="keyword">import</span>&nbsp;java.util.List<br/>
<br/>
class&nbsp;MyClass&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;first(List&lt;String&gt;&nbsp;elements)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;elements.get(0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="packageDecl"></a>
<h3>Package Declaration</h3>
<p>
Package declarations are like in Java, with the small difference, that an identifier can be escaped with a  <em>^</em> in case it conflicts with a keyword.
Also you don&apos;t terminate a package declaration with a semicolon.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
package&nbsp;org.eclipse.xtext<br/>
</p>
</div>
</div>

<div class="todo" >
Would be interesting to document how the following example translates to java
</div>
 
<div class="literallayout">
<div class="incode">
<p class="code">
package&nbsp;my.^public.^package<br/>
</p>
</div>
</div>
</p>
<a name="imports"></a>
<h3>Imports</h3>
<p>
The ordinary imports of type names are equivalent to the imports known from Java. 
Again one can escape any names conflicting with keywords using the <em>^</em>. In constrast to Java, the import statement is never
terminated with a semicolon. Xtend also features static imports but allows only a wildcard at the end.
So far you cannot import single members using a static import.
</p>
<p>
As in Java the package &apos;java.lang.*&apos; is implicitly imported.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">import</span>&nbsp;java.math.BigDecimal<br/>
<span class="keyword">import</span>&nbsp;java.math.*<br/>
<span class="keyword">import</span>&nbsp;static&nbsp;java.util.Collections.*<br/>
</p>
</div>
</div>
</p>
<p>
Xtend supports extension methods, which allows to add functions to existing classes without modifying
them. Static extension functions are just one possibility - simply put the keyword <span class="inlinecode"><span class="keyword">extension</span></span> after
the <span class="inlinecode">static</span> keyword and the static functions will be made available as member functions on their first
parameter&apos;s type.
</p>
<p>
That is the following import declaration 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">import</span>&nbsp;static&nbsp;<span class="keyword">extension</span>&nbsp;java.util.Collections.*<br/>
</p>
</div>
</div>
</p>
<p>
allows to use its methods for example like this :
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
new&nbsp;Foo().singletonList()<br/>
</p>
</div>
</div>
</p>
<p>
Although this is supported it is generally much nicer to use <a href="02-Xtend_Classes_Functions.html#fields" title="Go to &quot;Fields&quot;">injected extensions</a>, because
they don&apos;t bind you to the actual implementation.
</p>
<a name="Xtend_ClassDeclaration"></a>
<h3>Class Declaration</h3>
<p>
The class declaration reuses a lot of Java&apos;s syntax but still is a bit different in some aspects.
Firstly the default visibility of any class is <span class="inlinecode">public</span>. It is possible to write it explicitly but if not specified it defaults to public.
You can change the visibility to <span class="inlinecode">private</span> or <span class="inlinecode">protected</span>. Java&apos;s default "package private" visibility does not exist.
</p>
<p>
<em>To be implemented: </em>The <span class="inlinecode">abstract</span> as well as the <span class="inlinecode">final</span> modifiers are directly translated to Java and have the exact same meaning.
</p>
<a name="Xtend_ClassDeclaration_3"></a>
<h4>Inheritance</h4>
<p>
Also inheritance is directly reused from Java. Single inheritance of Java classes as well as implementing multiple Java interfaces
is supported.
</p>
<a name="Xtend_ClassDeclaration_4"></a>
<h4>Generics</h4>
<p>
Full Java Generics with the exact same syntax and semantics are supported. That is you can declare type
parameters just as in Java and provide type arguments to types you refer to (i.e. extend or implement).
</p>
<a name="Xtend_ClassDeclaration_5"></a>
<h4>Examples</h4>
<p>
The most simple class :
<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;MyClass&nbsp;{<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
A more advanced class declaration in Xtend :
<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;ArrayList&lt;E&gt;&nbsp;extends&nbsp;AbstractList&lt;E&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implements&nbsp;List&lt;E&gt;,&nbsp;RandomAccess,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cloneable,&nbsp;java.io.Serializable&nbsp;{<br/>
&nbsp;&nbsp;...<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="fields"></a>
<h3>Fields</h3>
<p>
Fields in Xtend are always private and are usually used together with an annotation for a dependency
injection container. Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Inject&nbsp;MyService&nbsp;myService<br/>
</p>
</div>
</div>
</p>
<p>
This will translate to the following Java field: 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Inject&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<span class="keyword">private</span>&nbsp;MyService&nbsp;myService;<br/>
</p>
</div>
</div>
</p>
<p>
Note that the visibility is always <span class="inlinecode">private</span>, is you want to provide access to an injected object
you need to write an accessor function. 
</p>
<a name="fields_6"></a>
<h4>Extension Methods</h4>
<p>
You can make the instance methods provided by the field available as extension
methods, by adding the keyword <span class="inlinecode"><span class="keyword">extension</span></span> to the field declaration.
</p>
<p>
Imagine you want to add a method &apos;fullName&apos; to a closed type &apos;Entity&apos;. With extension methods, you could declare the following class
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;PersonExtensions&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;def&nbsp;getFullName(Person&nbsp;p)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.forename&nbsp;+&nbsp;<span class="string">"&nbsp;"</span>&nbsp;+&nbsp;p.name<br/>
&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
And if you have an instance of this class injected as extension like this:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Inject&nbsp;<span class="keyword">extension</span>&nbsp;PersonExtensions&nbsp;personExtensions<br/>
</p>
</div>
</div>
</p>
<p>
The method is being put on the member scope of Person.
So you can write the following
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myPerson.getFullName()<br/>
</p>
</div>
</div>
</p>
<p>
which is the a shorthand for 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
personExtensions.getFullName(myPerson)<br/>
</p>
</div>
</div>
</p>
<p>
Of course the property shorthand is also available
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myPerson.fullName<br/>
</p>
</div>
</div>
</p>
<p>
The nice thing with using dependency injection in combination with the extension modifier as opposed to <a href="02-Xtend_Classes_Functions.html#imports" title="Go to &quot;Imports&quot;">static extensions</a> is, that in case there is a bug in the extension or it is implemented inefficiently or you 
just need a different strategy, you can simply exchange the component with another implementation. You do this without modifying the library nor the client code. 
You&apos;ll only have to change the binding in your guice module. Also this gives you a general hook for any AOP-like thing you would want to do, 
or allows you to write against an SPI, where the concrete implementation can be provided by a third party.
</p>
<a name="Functions"></a>
<h3>Functions</h3>
<p>
Xtend functions are declared within a class and are translated to a corresponding Java method with the exact same signature. 
(The only exceptions are dispatch methods, which are explained <a href="02-Xtend_Classes_Functions.html#polymorphicDispatch" title="Go to &quot;Dispatch Functions&quot;">here</a>). 
</p>
<p>
Let&apos;s start with a simple example
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
def&nbsp;boolean&nbsp;equalsIgnoreCase(String&nbsp;s1,&nbsp;String&nbsp;s2)&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s1.toLowerCase()&nbsp;==&nbsp;s2.toLowerCase();<br/>
</p>
</div>
</div>
</p>
<a name="Functions_4"></a>
<h4>Visibility</h4>
<p>
So far the visibility of any function is <span class="inlinecode">public</span>. 
It is planned to add support for <span class="inlinecode">protected</span> and <span class="inlinecode">private</span>.
</p>
<a name="Xtend_Classes_Functions_8"></a>
<h3>Overriding Functions</h3>
<p>
Functions can override a function/method from the super class or implemented interfaces using the keyword <span class="inlinecode">override</span>.
If a function is annotated with the keyword <span class="inlinecode">final</span>, it cannot be overridden.
IF a function overrides a function (or method) from a super type, the <span class="inlinecode">override</span> keyword is mandatory and replaces the keyword <span class="inlinecode">def</span>.
</p>
<p>
Example:
<div class="literallayout">
<div class="incode">
<p class="code">
override&nbsp;boolean&nbsp;equalsIgnoreCase(String&nbsp;s1,String&nbsp;s2)&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s1.toLowerCase()&nbsp;==&nbsp;s2.toLowerCase();<br/>
</p>
</div>
</div>
</p>
<a name="declaredExceptions"></a>
<h4>Declared Exceptions</h4>
<p>
<em>To be implemented: </em>
</p>
<p>
Xtend doesn&apos;t force you to catch checked exceptions. If a called method throws a checked exception and
it is not catched or explicitly declared to be rethrown it will be wrapped in a runtime exception and rethrown.
</p>
<p>
A declared checked exception will not be wrapped automatically.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="comment">/*<br/>
&nbsp;*&nbsp;throws&nbsp;an&nbsp;IOException<br/>
&nbsp;*/</span><br/>
def&nbsp;void&nbsp;throwIOException()&nbsp;throws&nbsp;IOException&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IOException()<br/>
}<br/>
<br/>
<span class="comment">/*<br/>
&nbsp;*&nbsp;throws&nbsp;a&nbsp;WrappedException<br/>
&nbsp;*/</span><br/>
def&nbsp;void&nbsp;throwWrappedException()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IOException()<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="inferredReturnTypes"></a>
<h4>Inferred Return Types</h4>
<p>
If the return type of a function can be inferred it does not need to be declared.
That is the function
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
def&nbsp;boolean&nbsp;equalsIgnoreCase(String&nbsp;s1,String&nbsp;s2)&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s1.toLowerCase()&nbsp;==&nbsp;s2.toLowerCase();<br/>
</p>
</div>
</div>
</p>
<p>
could be declared like this:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
def&nbsp;equalsIgnoreCase(String&nbsp;s1,String&nbsp;s2)&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s1.toLowerCase()&nbsp;==&nbsp;s2.toLowerCase();<br/>
</p>
</div>
</div>
</p>
<p>
This doesn&apos;t work for abstract function declarations as well as if the 
return type of a function depends on a recursive call of the same function.
The compiler tells the user when it needs to be specified.
</p>
<a name="Xtend_Classes_Functions_8_5"></a>
<h4>Generics</h4>
<p>
Full Java Generics with the exact same syntax and semantics as in Java are supported.
</p>
<a name="polymorphicDispatch"></a>
<h4>Dispatch Functions</h4>
<p>
Generally function binding works just like method binding in Java. That is function calls are bound based
on the static types of arguments. Sometimes this is not what you want. Especially in the context of extension
methods one would like to have polymorphic behavior.
</p>
<p>
Dispatch functions make a set of overloaded functions polymorphic. That is the runtime types of all given arguments are 
used to decide which of the overloaded methods is being invoked. This essentially removes the need for the quite invasive visitor pattern.
</p>
<p>
A dispatch function is marked using the keyword <span class="inlinecode">dispatch</span>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
def&nbsp;dispatch&nbsp;foo(Number&nbsp;x)&nbsp;{&nbsp;<span class="string">"it&apos;s&nbsp;a&nbsp;number"</span>&nbsp;}<br/>
def&nbsp;dispatch&nbsp;foo(Integer&nbsp;x)&nbsp;{&nbsp;<span class="string">"it&apos;s&nbsp;an&nbsp;int"</span>&nbsp;}<br/>
</p>
</div>
</div>
</p>
<p>
For a set of visible dispatch functions in the current type hierarchy, the compiler infers a common
signature using the common super type of all declared arguments and generates a Java method made up of if-else cascades. It dispatches to the 
different available functions. The actually declared methods are all compiled to a Java method that is
prefixed with an underscore.
</p>
<p>
For the two dispatch methods in the example above the following Java code would be generated:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;String&nbsp;foo(Number&nbsp;x)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;<span class="keyword">instanceof</span>&nbsp;Integer)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Integer)x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;<span class="keyword">instanceof</span>&nbsp;Number)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Number)x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalArgumentException(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"Couldn&apos;t&nbsp;handle&nbsp;argument&nbsp;x:"</span>+x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}&nbsp;<br/>
<br/>
<span class="keyword">protected</span>&nbsp;String&nbsp;_foo(Integer&nbsp;x)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="string">"It&apos;s&nbsp;an&nbsp;int"</span>;<br/>
}<br/>
<br/>
<span class="keyword">protected</span>&nbsp;String&nbsp;_foo(Number&nbsp;x)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="string">"It&apos;s&nbsp;a&nbsp;number"</span>;<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Note that the instanceof cascade is ordered by how specific a type is. More specific types come first.
</p>
<p>
In case there is no single most general signature, one is computed and the
different overloaded methods are matched in the order they are declared within the class file.
Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
def&nbsp;dispatch&nbsp;foo(Number&nbsp;x,&nbsp;Integer&nbsp;y)&nbsp;{&nbsp;<span class="string">"it&apos;s&nbsp;some&nbsp;number&nbsp;and&nbsp;an&nbsp;int"</span>&nbsp;}<br/>
def&nbsp;dispatch&nbsp;foo(Integer&nbsp;x,&nbsp;Number&nbsp;x)&nbsp;{&nbsp;<span class="string">"it&apos;s&nbsp;an&nbsp;int&nbsp;and&nbsp;a&nbsp;number"</span>&nbsp;}<br/>
</p>
</div>
</div>
</p>
<p>
generates the following Java code :
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;String&nbsp;foo(Number&nbsp;x,&nbsp;Number&nbsp;y)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;((x&nbsp;<span class="keyword">instanceof</span>&nbsp;Number)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(y&nbsp;<span class="keyword">instanceof</span>&nbsp;Integer))&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Number)x,(Integer)y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;((x&nbsp;<span class="keyword">instanceof</span>&nbsp;Integer)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(y&nbsp;<span class="keyword">instanceof</span>&nbsp;Number)){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Integer)x,(Number)y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalArgumentException(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"Couldn&apos;t&nbsp;handle&nbsp;argument&nbsp;x:"</span>+x+<span class="string">",&nbsp;argument&nbsp;y:"</span>+y);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
As you can see a null reference is never a match. If you want to fetch null you can declare a parameter using the type <span class="inlinecode">java.lang.Void</span>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
def&nbsp;dispatch&nbsp;foo(Number&nbsp;x)&nbsp;{&nbsp;<span class="string">"it&apos;s&nbsp;some&nbsp;number"</span>&nbsp;}<br/>
def&nbsp;dispatch&nbsp;foo(Integer&nbsp;x)&nbsp;{&nbsp;<span class="string">"it&apos;s&nbsp;an&nbsp;int"</span>&nbsp;}<br/>
def&nbsp;dispatch&nbsp;foo(Void&nbsp;x)&nbsp;{&nbsp;throw&nbsp;new&nbsp;NullPointerException(<span class="string">"x"</span>)&nbsp;}<br/>
</p>
</div>
</div>
</p>
<p>
Which compiles to the following Java code:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;String&nbsp;foo(Number&nbsp;x)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;<span class="keyword">instanceof</span>&nbsp;Integer)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Integer)x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;<span class="keyword">instanceof</span>&nbsp;Number){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Number)x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(x&nbsp;==&nbsp;<span class="keyword">null</span>)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Void)<span class="keyword">null</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalArgumentException(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"Couldn&apos;t&nbsp;handle&nbsp;argument&nbsp;x:"</span>+x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}&nbsp;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Classes_Functions_8_7"></a>
<h4>Overloading Functions from Super Types</h4>
<p>
Any visible Java methods from super types conforming to the compiled form of a dispatch method are also included in the
dispatch. Conforming means they have the right number of arguments and have the same name (starting with an underscore).
</p>
<p>
For example, consider the following Java class :
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">abstract</span>&nbsp;<span class="keyword">class</span>&nbsp;AbstractLabelProvider&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">protected</span>&nbsp;String&nbsp;_label(Object&nbsp;o)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;some&nbsp;generic&nbsp;implementation<br/>
</span>&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
and the following Xtend class which extends the Java class :
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;MyLabelProvider&nbsp;extends&nbsp;AbstractLabelProvider&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;def&nbsp;dispatch&nbsp;label(Entity&nbsp;<span class="keyword">this</span>)&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name<br/>
&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;def&nbsp;dispatch&nbsp;label(Method&nbsp;<span class="keyword">this</span>)&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name+<span class="string">"("</span>+params.toString(<span class="string">","</span>)+<span class="string">"):"</span>+type<br/>
&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;def&nbsp;dispatch&nbsp;label(Field&nbsp;<span class="keyword">this</span>)&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name+type<br/>
&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The resulting dispatch method in the generated Java class &apos;MyLabelProvider&apos; would then look like this:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;String&nbsp;label(Object&nbsp;o)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(o&nbsp;<span class="keyword">instanceof</span>&nbsp;Field)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_label((Field)o);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(o&nbsp;<span class="keyword">instanceof</span>&nbsp;Method){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Method)o);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(o&nbsp;<span class="keyword">instanceof</span>&nbsp;Entity){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Entity)o);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(o&nbsp;<span class="keyword">instanceof</span>&nbsp;Object){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;_foo((Object)o);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalArgumentException(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"Couldn&apos;t&nbsp;handle&nbsp;argument&nbsp;o:"</span>+o);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="CreateFunctions"></a>
<h3>Create Functions</h3>
<p>
Create functions in Xtend allow to do graph transformation in one pass where it usually needs two passes.
That means you don&apos;t need to separate a translation from one graph to another in the typical two phases:
tree construction and interlinking the tree nodes. You basically just need to write the whole transformation using
create functions and the built-in identity preservation will take care of the rest.
</p>
<p>
Consider you want to create a copy of the following list of persons into a :
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Fred&nbsp;Flintstone&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;marriedTo&nbsp;Willma&nbsp;Flintstone<br/>
&nbsp;&nbsp;&nbsp;&nbsp;friendWith&nbsp;Barny&nbsp;Rubble<br/>
}<br/>
Willma&nbsp;Flintstone&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;marriedTo&nbsp;Fred&nbsp;Flintstone<br/>
}<br/>
Barny&nbsp;Rubble&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;friendWith&nbsp;Fred&nbsp;Flintstone<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
A function like the following could do the trick :
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
def&nbsp;List&lt;Person&gt;&nbsp;copyPersons(List&lt;Person&gt;&nbsp;persons)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;persons.map(&nbsp;p&nbsp;|&nbsp;p.copy&nbsp;)<br/>
}<br/>
<br/>
def&nbsp;copy(Person&nbsp;p)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;result&nbsp;=&nbsp;new&nbsp;Person()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result.name&nbsp;=&nbsp;p.name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;The&nbsp;following&nbsp;is&nbsp;wrong&nbsp;and&nbsp;results&nbsp;in&nbsp;a&nbsp;stack&nbsp;overflow<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;result.friendWith&nbsp;=&nbsp;p.friendWith.map(&nbsp;p&nbsp;|&nbsp;p.copy&nbsp;)&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result.marriedWith&nbsp;=&nbsp;p.marriedWith.map(&nbsp;p&nbsp;|&nbsp;p.copy&nbsp;)&nbsp;<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The problem with that code is that we don&apos;t track the origins of the created copies. This is the
main problem with model transformations. The classic solution is to run the copying in two passes.
First we create all instances and then we establish the links. Although it works it results in cluttered
and non coherent code. Xtend&apos;s create functions handle this problem by introducing identity perservation by
tracking the origin of each created instance. Therefore, a create function takes two expressions. One to instantiate the actual
object and a second one to initialize it. 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
def&nbsp;<span class="keyword">create</span>&nbsp;result:&nbsp;new&nbsp;Person()&nbsp;copy(Person&nbsp;p)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result.name&nbsp;=&nbsp;p.name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;now&nbsp;it&nbsp;works&nbsp;&nbsp;&nbsp;&nbsp;<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;result.friendWith&nbsp;=&nbsp;p.friendWith.map(&nbsp;p&nbsp;|&nbsp;p.copy&nbsp;)&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result.marriedWith&nbsp;=&nbsp;p.marriedWith.map(&nbsp;p&nbsp;|&nbsp;p.copy&nbsp;)&nbsp;<br/>
}&nbsp;&nbsp;&nbsp;&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
It is even possible to define the return type of a create function by means of
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
def&nbsp;Person&nbsp;<span class="keyword">create</span>&nbsp;r:&nbsp;new&nbsp;PersonImpl()&nbsp;copy(Person&nbsp;p)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;r.name&nbsp;=&nbsp;p.name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;r.friendWith&nbsp;=&nbsp;p.friendWith.map(&nbsp;p&nbsp;|&nbsp;p.copy&nbsp;)&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;r.marriedWith&nbsp;=&nbsp;p.marriedWith.map(&nbsp;p&nbsp;|&nbsp;p.copy&nbsp;)&nbsp;<br/>
}&nbsp;&nbsp;&nbsp;&nbsp;<br/>
</p>
</div>
</div>
</p>
<a name="CreateFunctions_10"></a>
<h4>How it works</h4>
<p>
In addition to the keyword <span class="inlinecode"><span class="keyword">create</span></span> one specifies two expressions.
The first expression is the factory to create an instance while the second will initialize it further.
Prior to invoking the factory expression, a cache lookup is performed to find a previously created instance
for the very same arguments. If there is no such instance, the factory expression is evaluated and the
result is stored in the cache. Subsequently the main expression (also called the initializer expression) is evaluated.
This happens only if there was no previously created instance available in the cache. If that expression
in turn calls the create function transitively using the same set of arguments the previously instantiated and cached object is returned.
Note that the object is probably currently initialized. That is, its internal state may not yet be available.
</p>
<p>
The lifecycle of the cache is attached to the instance of the declaring Xtend class. That is you can control
how long the cache lives by means of Guice.
</p>
<a name="Annotations"></a>
<h3>Annotations</h3>
<p>
Xtend supports Java annotations. The syntax is exactly like defined in the Java Language Specification.
Annotations are available on classes, fields, functions and parameters.
</p>
<p>
Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@TypeAnnotation(typeof(String))<br/>
class&nbsp;MyClass&nbsp;{<br/>
&nbsp;&nbsp;@FieldAnnotation(children&nbsp;=&nbsp;{@MyAnno(<span class="keyword">true</span>),&nbsp;@MyAnnot(<span class="keyword">false</span>)}<br/>
&nbsp;&nbsp;String&nbsp;myField<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;@MethodAnnotation(children&nbsp;=&nbsp;{@MyAnno(<span class="keyword">true</span>),&nbsp;@MyAnnot}<br/>
&nbsp;&nbsp;def&nbsp;String&nbsp;myMethod(@ParameterAnnotation&nbsp;String&nbsp;param)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//...<br/>
</span>&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions"></a>
<h2>Expressions</h2>
<p>
The most important part of a function is of course its implementation, which in Xtend is either a single
<a href="03-Xtend_Expressions.html#Xtend_Expressions_Blocks" title="Go to &quot;Blocks&quot;">block expression</a> or a <a href="03-Xtend_Expressions.html#Xtend_RichStrings" title="Go to &quot;Rich Strings&quot;">rich string expression</a>. 
</p>
<a name="Xtend_Expressions_Literals"></a>
<h3>Literals</h3>
<p>
A literal denotes a fixed unchangeable value. Literals for string, integers, booleans,
null and Java types are supported.
</p>
<a name="Xtend_Expressions_StringLiterals"></a>
<h4>String Literals</h4>
<p>
A string literal is a valid expression and returns an instance of <span class="inlinecode">java.lang.String</span> of the given value.
</p>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="string">&apos;Hello&nbsp;World&nbsp;!&apos;</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="string">"Hello&nbsp;World&nbsp;!"</span></span>
	</li>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="string">"Hello&nbsp;<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;World&nbsp;!"</span><br/>
		</p>
		</div>
		</div>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_IntegerLiterals"></a>
<h4>Integer Literals</h4>
<p>
An integer literal creates an <span class="inlinecode">int</span>.
There is no signed int. If you put a minus operator in front of an int literal it is taken as a UnaryOperator
with one argument (the positive int literal).
</p>
<p>
<ul>
	<li>
		<span class="inlinecode">42</span>
	</li>
	<li>
		<span class="inlinecode">234254</span>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_BooleanLiteral"></a>
<h4>Boolean Literals</h4>
<p>
There are two boolean literals, <span class="inlinecode">true</span> and <span class="inlinecode">false</span> which correspond to their Java counterpart of type <em>boolean</em>. 
</p>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">true</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">false</span></span>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_NullLiteral"></a>
<h4>Null Literal</h4>
<p>
The null pointer literal is, like in Java, <span class="inlinecode">null</span>. 
It is a member of any reference type.
</p>
<p>
<ul>
	<li>
		<span class="inlinecode">null</span>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_TypeLiteral"></a>
<h4>Type Literals</h4>
<p>
Type literals are specified using the keyword <em>typeof</em> :
</p>
<p>
<ul>
	<li>
		<span class="inlinecode">typeof(java.lang.String)</span> which yields java.lang.String.class
	</li>
</ul>
</p>
<a name="Xtend_Expressions_TypeCasts"></a>
<h3>Type Casts</h3>
<p>
Type cast behave like casts in Java, but have a slightly more readable syntax.
Type casts bind stronger than any other operator but weaker than feature calls.
</p>
<p>
The conformance rules for casts are defined in the <a href="http://java.sun.com/docs/books/jls/third_edition/html/conversions.html#5.5">Java Language Specification</a>.
</p>
<a name="Xtend_Expressions_TypeCasts_3"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XCastedExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;<span class="string">&apos;as&apos;</span>&nbsp;JvmTypeReference;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_TypeCasts_4"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">my.foo&nbsp;as&nbsp;MyType</span>
	</li>
	<li>
		<span class="inlinecode">(1&nbsp;+&nbsp;3&nbsp;*&nbsp;5&nbsp;*&nbsp;(-&nbsp;23))&nbsp;as&nbsp;BigInteger</span>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_Operators"></a>
<h3>Infix Operators / Operator Overloading</h3>
<p>
There are a couple of common predefined infix operators. In contrast to Java, the operators are not limited
to operations on certain types. Instead an operator-to-method mapping allows users to redefine the 
operators for any type just by implementing the corresponding method signature.
The following defines the operators and the corresponding Java method signatures / expressions.
</p>
<p>
<table>
<tr>
<td>
<span class="inlinecode">e1&nbsp;+=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_add(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;||&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_or(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&amp;&amp;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_and(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;==&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_equals(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;!=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_notEquals(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_lessThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_greaterThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_lessEqualsThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_greaterEqualsThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_mappedTo(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;..&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_upTo(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;+&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_plus(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_minus(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;*&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_multiply(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;/&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_divide(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;%&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_modulo(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;**&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_power(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">!&nbsp;e1</span>
</td>
<td>
<span class="inlinecode">e1._operator_not()</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">-&nbsp;e1</span>
</td>
<td>
<span class="inlinecode">e1._operator_minus()</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
</table>

		
The table above also defines the operator precedence in ascending order. The blank lines separate precedence levels. 
The assignment operator <span class="inlinecode">+=</span> is right-to-left associative in the same way as the plain assignment
operator <span class="inlinecode">=</span> is. That is a = b = c is executed as a = (b = c), all other
operators are left-to-right associative. Parenthesis can be used to adjust the default precedence and associativity. 
</p>
<a name="Xtend_Expressions_Operators_3"></a>
<h4>Short-Circuit Boolean Operators</h4>
<p>
If the operators <span class="inlinecode">||</span> and <span class="inlinecode">&amp;&amp;</span> are used in a context where the left hand operand is of type boolean, the operation is evaluated
in short circuit mode, which means that the right hand operand might not be evaluated at all in the following cases: 
<ol>
	<li>
		in the case of <span class="inlinecode">||</span> the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode"><span class="keyword">true</span></span>.
	</li>
	<li>
		in the case of <span class="inlinecode">&amp;&amp;</span> the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode"><span class="keyword">false</span></span>.
	</li>
</ol>
</p>
<a name="Xtend_Expressions_Operators_4"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">myList&nbsp;+=&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">x&nbsp;&gt;&nbsp;23&nbsp;&amp;&amp;&nbsp;y&nbsp;&lt;&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">x&nbsp;&amp;&amp;&nbsp;y&nbsp;||&nbsp;z</span>
	</li>
	<li>
		<span class="inlinecode">1&nbsp;+&nbsp;3&nbsp;*&nbsp;5&nbsp;*&nbsp;(-&nbsp;23)</span>
	</li>
	<li>
		<span class="inlinecode">!(x)</span>
	</li>
	<li>
		<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_PropertyAssignment"></a>
<h4>Assignments</h4>
<p>
<a href="03-Xtend_Expressions.html#Xtend_Expressions_VariableDeclaration" title="Go to &quot;Variable Declarations&quot;">Local variables</a> can be reassigned using the <span class="inlinecode">=</span> operator. Also properties can be set using 
that operator:
Given the expression 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty&nbsp;=&nbsp;<span class="string">"foo"</span><br/>
</p>
</div>
</div>
</p>
<p>
The compiler first looks up whether there is an accessible Java Field called <span class="inlinecode">myProperty</span> on the type of <span class="inlinecode">myObj</span>. If there is one it translates to
the following Java expression :
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty&nbsp;=&nbsp;<span class="string">"foo"</span>;<br/>
</p>
</div>
</div>
</p>
<p>
Remember in Xtend everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
Java expression, which is the assigned value.
</p>
<p>
If there is no accessible field on the left operand&apos;s type, a method called <span class="inlinecode">setMyProperty(OneArg)</span> (JavaBeans
setter method) is looked up. It has to take one argument of the type (or a super type) of the right hand operand. The return value will be whatever the 
setter method returns (which usually is <span class="inlinecode">null</span>). 
As a result the compiler translates to :
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myObj.setMyProperty(<span class="string">"foo"</span>)<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_FeatureCalls"></a>
<h3>Feature Calls</h3>
<p>
A feature call is used to invoke members of objects, such as fields and methods, but also can refer to local variables and parameters, 
which are made available for the current expression&apos;s scope. 
</p>
<a name="Xtend_Expressions_FeatureCalls_2"></a>
<h4>Syntax</h4>
<p>
The following snippet is a simplification of the real Xtext rules, which cover more than the concrete syntax.
<div class="literallayout">
<div class="incode">
<p class="code">
FeatureCall&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ID&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;(<span class="string">&apos;.&apos;</span>&nbsp;ID&nbsp;(<span class="string">&apos;(&apos;</span>&nbsp;Expression&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;Expression)*&nbsp;<span class="string">&apos;)&apos;</span>)?)*<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_PropertyAccess"></a>
<h4>Property Access</h4>
<p>
Feature calls are directly translated to their Java equivalent with the exception, that for calls to properties an equivalent rule as 
described in <a href="03-Xtend_Expressions.html#Xtend_Expressions_PropertyAssignment" title="Go to &quot;Assignments&quot;" >section Xtend_Expressions_PropertyAssignment</a> applies. 
That is, for the following expression
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty<br/>
</p>
</div>
</div>
</p>
<p>
the compiler first looks for an accessible field in the type of <span class="inlinecode">myObj</span>. If no such field exists it looks for a method called <span class="inlinecode">myProperty()</span> before it looks 
for the getter methods <span class="inlinecode">getMyProperty()</span>. If none of these members can be found the expression is unbound and a compiliation error is thrown.
</p>
<a name="Xtend_Expressions_ImplicitThis"></a>
<h4>Implicit 'this' variable</h4>
<p>
If the current scope contains a variable named <span class="inlinecode"><span class="keyword">this</span></span>, the compiler will make all its members available to the scope. 
That is if 
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">this</span>.myProperty<br/>
</p>
</div>
</div>

is a valid expression
<div class="literallayout">
<div class="incode">
<p class="code">
myProperty<br/>
</p>
</div>
</div>

is valid as well and is equivalent, as long as there is no local variable &apos;myProperty&apos; on the scope,
which would have higher precedence.
</p>
<a name="Xtend_Expressions_NullSafeFeatureCalls"></a>
<h4>Null-Safe Feature Call</h4>
<p>
Checking for null references can make code very unreadable. In many situations it is ok for an expression to return null if a receiver was null.
Xtend supports the safe navigation operator <span class="inlinecode">?.</span> to make such code more readable.
</p>
<p>
Instead of writing 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">if</span>&nbsp;(&nbsp;myRef&nbsp;!=&nbsp;<span class="keyword">null</span>&nbsp;)&nbsp;myRef.doStuff()<br/>
</p>
</div>
</div>
</p>
<p>
one can write
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myRef?.doStuff()<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_ConstructorCall"></a>
<h3>Constructor Call</h3>
<p>
Construction of objects is done by invoking Java constructors. The syntax is exactly as in Java.
</p>
<a name="Xtend_Expressions_ConstructorCall_2"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		new&nbsp;String()<br/>
		</p>
		</div>
		</div>
		
	</li>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		new&nbsp;java.util.ArrayList&lt;java.math.BigDecimal&gt;()<br/>
		</p>
		</div>
		</div>
		
	</li>
</ul>
</p>
<a name="Xtend_Expressions_ConstructorCall_3"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XConstructorCall:<br/>
&nbsp;&nbsp;<span class="string">&apos;new&apos;</span>&nbsp;QualifiedName&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;&lt;&apos;</span>&nbsp;JvmTypeArgument&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;JvmTypeArgument)*&nbsp;<span class="string">&apos;&gt;&apos;</span>)?&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;(&apos;</span>(XExpression&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;XExpression)*)?<span class="string">&apos;)&apos;</span>)?;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_Closures"></a>
<h3>Closures</h3>
<p>
A closure is a literal that defines an anonymous function. A closure also captures the current scope,
so that any final variables and parameters visible at construction time can be referred to in the closure&apos;s expression. 
</p>
<a name="Xtend_Expressions_Closures_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XClosure:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;[&apos;</span>&nbsp;(&nbsp;JvmFormalParameter&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;JvmFormalParameter)*&nbsp;)?&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;|&apos;</span>&nbsp;XExpression&nbsp;<span class="string">&apos;]&apos;</span>;<br/>
</p>
</div>
</div>
</p>
<p>
The surrounding square brackets are optional if the closure is the single argument of a method invocation.
That is you can write
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myList.find(e|e.name==null)<br/>
</p>
</div>
</div>
</p>
<p>
instead of
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myList.find([e|e.name==null])<br/>
</p>
</div>
</div>
</p>
<p>
But in all other cases the square brackets are mandatory:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
val&nbsp;func&nbsp;=&nbsp;[String&nbsp;s|&nbsp;s.length&gt;3]<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_ClosuresTypeInference"></a>
<h4>Typing</h4>
<p>
Closures are expressions which produce function objects. The type is a <a href="199g-xbase-language-reference-types.html#Xbase_Types_FunctionTypes" title="Go to &quot;Function Types&quot;">function type</a>, consisting of the types of the 
parameters as well as the return type. The return type is never specified explicitly but is always inferred from the expression. 
The parameter types can be inferred if the closure is used in a context where this is possible.
</p>
<p>
For instance, given the following Java method signature:
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;T&nbsp;&lt;T&gt;getFirst(List&lt;T&gt;&nbsp;list,&nbsp;Function0&lt;T,Boolean&gt;&nbsp;predicate)&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
the type of the parameter can be inferred. Which allows users to write:
<div class="literallayout">
<div class="incode">
<p class="code">
arrayList(&nbsp;<span class="string">"Foo"</span>,&nbsp;<span class="string">"Bar"</span>&nbsp;).findFirst(&nbsp;e&nbsp;|&nbsp;e&nbsp;==&nbsp;<span class="string">"Bar"</span>&nbsp;)<br/>
</p>
</div>
</div>

instead of 
<div class="literallayout">
<div class="incode">
<p class="code">
arrayList(&nbsp;<span class="string">"Foo"</span>,&nbsp;<span class="string">"Bar"</span>&nbsp;).findFirst(&nbsp;String&nbsp;e&nbsp;|&nbsp;e&nbsp;==&nbsp;<span class="string">"Bar"</span>&nbsp;)<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_FunctionMapping"></a>
<h4>Function Mapping</h4>
<p>
An Xtend closure is a Java object of one of the <em>Function</em> interfaces shipped with the runtime library of Xtend. There is an interface 
for each number of parameters (current maximum is six parameters). The names of the interfaces are 
<ul>
	<li>
		<em>Function0&lt;ReturnType&gt;</em> for zero parameters, 
	</li>
	<li>
		<em>Function1&lt;Param1Type, ReturnType&gt;</em> for one parameters, 
	</li>
	<li>
		<em>Function2&lt;Param1Type, Param2Type, ReturnType&gt;</em> for two parameters, 
	</li>
	<li>
		... 
	</li>
	<li>
		<em>Function6&lt;Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType&gt;</em> for six parameters, 
	</li>
</ul>
</p>
<p>
In order to allow seamless integration with existing Java libraries such as the JDK or Google Guava (formerly known as Google Collect) closures
are auto coerced to expected types if those types declare only one method (methods from java.lang.Object
don&apos;t count).
</p>
<p>
As a result given the method <span class="inlinecode">java.util.Collections.sort(List&lt;T&gt;,&nbsp;Comparator&lt;?&nbsp;super&nbsp;T&gt;)</span> is available
as an extension method, it can be invoked like this
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
newArrayList(&nbsp;<span class="string">&apos;aaa&apos;</span>,&nbsp;<span class="string">&apos;bb&apos;</span>,&nbsp;<span class="string">&apos;c&apos;</span>&nbsp;).sort(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e1,&nbsp;e2&nbsp;|&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;e1.length&nbsp;&gt;&nbsp;e2.length&nbsp;)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;e1.length&nbsp;&lt;&nbsp;e2.length&nbsp;)&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_Closures_5"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">[&nbsp;|&nbsp;<span class="string">"foo"</span>&nbsp;]&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;closure&nbsp;without&nbsp;parameters</span></span>
	</li>
	<li>
		<span class="inlinecode">[&nbsp;String&nbsp;s&nbsp;|&nbsp;s.toUpperCase()&nbsp;]&nbsp;<span class="comment">//&nbsp;explicit&nbsp;argument&nbsp;type</span></span>
	</li>
	<li>
		<span class="inlinecode">[&nbsp;a,b,a&nbsp;|&nbsp;a+b+c&nbsp;]&nbsp;<span class="comment">//&nbsp;inferred&nbsp;argument&nbsp;types</span></span>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_IfExpression"></a>
<h3>If Expression</h3>
<p>
An if expression is used to choose two different values based on a predicate. While it has the syntax of Java&apos;s if statement it behaves  
like Java&apos;s ternary operator (<span class="inlinecode">predicate&nbsp;?&nbsp;thenPart&nbsp;:&nbsp;elsePart</span>), i.e. it is an expression that returns a value. Consequently, you can use 
if expressions deeply nested within expressions.
</p>
<a name="Xtend_Expressions_IfExpression_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XIfExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;if&apos;</span>&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;XExpression&nbsp;<span class="string">&apos;)&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XExpression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;else&apos;</span>&nbsp;XExpression)?;<br/>
</p>
</div>
</div>
</p>
<p>
An expression <span class="inlinecode"><span class="keyword">if</span>&nbsp;(p)&nbsp;e1&nbsp;<span class="keyword">else</span>&nbsp;e2</span> results in either the value <span class="inlinecode">e1</span> or <span class="inlinecode">e2</span> depending on whether the predicate <span class="inlinecode">p</span> 
evaluates to <span class="inlinecode"><span class="keyword">true</span></span> or <span class="inlinecode"><span class="keyword">false</span></span>. The else part is optional which is a shorthand for <span class="inlinecode"><span class="keyword">else</span>&nbsp;null</span>.
That means 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">if</span>&nbsp;(foo)&nbsp;x&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
is the a short hand for
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">if</span>&nbsp;(foo)&nbsp;x&nbsp;<span class="keyword">else</span>&nbsp;null<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_IfTypeInference"></a>
<h4>Typing</h4>
<p>
The type of an if expression is calculated by the return types <span class="inlinecode">T1</span> and <span class="inlinecode">T2</span> of the two expression <span class="inlinecode">e1</span> and <span class="inlinecode">e2</span>.
It uses the rules defined in <a href="199g-xbase-language-reference-types.html#Xbase_Types_CommonSuperType" title="Go to &quot;Common Super Type&quot;" >section Xbase_Types_CommonSuperType</a>.
</p>
<a name="Xtend_Expressions_IfExpression_4"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">if</span>&nbsp;(isFoo)&nbsp;<span class="keyword">this</span>&nbsp;<span class="keyword">else</span>&nbsp;that</span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">if</span>&nbsp;(isFoo)&nbsp;{&nbsp;<span class="keyword">this</span>&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(thatFoo)&nbsp;{&nbsp;that&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{&nbsp;other&nbsp;}</span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">if</span>&nbsp;(isFoo)&nbsp;<span class="keyword">this</span></span>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_SwitchExpression"></a>
<h3>Switch Expression</h3>
<p>
The switch expression is a bit different from Java&apos;s. First, there is no fall through which means only one case is evaluated at most.
Second, the use of switch is not limited to certain values but can be used for any object reference instead.
 
For a switch expression 
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">switch</span>&nbsp;e&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;e1&nbsp;:&nbsp;er1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;e2&nbsp;:&nbsp;er2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;en&nbsp;:&nbsp;ern<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;er<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
the main expression <span class="inlinecode">e</span> is evaluated first and then each case sequentially. If the switch expression
contains a variable declaration using the syntax known from <a href="03-Xtend_Expressions.html#Xtend_Expressions_ForLoop" title="Go to &quot;For Loop&quot;" >section Xtend_Expressions_ForLoop</a>, the value is bound to the given name.
Expressions of type <span class="inlinecode">java.lang.Boolean</span> or <span class="inlinecode">boolean</span> are not allowed in a switch expression.
</p>
<p>
The guard of each case clause is evaluated until the switch value equals the result of the case&apos;s guard expression or if the case&apos;s guard expression evaluates to <span class="inlinecode">true</span>.
Then the right hand expression of the case evaluated and the result is returned.
</p>
<p>
If none of the guards matches the default expression is evaluated an returned. If no default expression
is specified the expression evaluates to <span class="inlinecode">null</span>.
</p>
<p>
Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">switch</span>&nbsp;myString&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;myString.length&gt;5&nbsp;:&nbsp;<span class="string">&apos;a&nbsp;long&nbsp;string.&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;:&nbsp;<span class="string">&apos;It&apos;</span>s&nbsp;a&nbsp;foo.<span class="string">&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;&apos;</span>It<span class="string">&apos;s&nbsp;a&nbsp;short&nbsp;non-foo&nbsp;string.&apos;</span><br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_SwitchExpression_7"></a>
<h4>Type guards</h4>
<p>
In addition to the case guards one can add a so called <em>Type Guard</em> which is syntactically just a <a href="199g-xbase-language-reference-types.html#Xbase_Types_TypeReferences" title="Go to &quot;Simple Type References&quot;">type reference</a> preceding
the than optional case keyword. The compiler will use that type for the switch expression in subsequent expressions.
Example:
<div class="literallayout">
<div class="incode">
<p class="code">
var&nbsp;Object&nbsp;x&nbsp;=&nbsp;...;<br/>
<span class="keyword">switch</span>&nbsp;x&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;<span class="keyword">case</span>&nbsp;x.length()&gt;0&nbsp;:&nbsp;x.length()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;List&lt;?&gt;&nbsp;:&nbsp;x.size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;-1<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Only if the switch value passes a type guard, i.e. an instanceof operation returns <span class="inlinecode">true</span>, the case&apos;s guard expression is executed using the same semantics explained in
previously. 
If the switch expression contains an explicit declaration of a local variable or the expression references a local variable,
the type guard acts like a cast, that is all references to the switch value will be of the type specified in the type guard.
</p>
<a name="Xtend_Expressions_SwitchExpression_8"></a>
<h4>Typing</h4>
<p>
The return type of a switch expression is computed using the rules defined in <a href="199g-xbase-language-reference-types.html#Xbase_Types_CommonSuperType" title="Go to &quot;Common Super Type&quot;" >section Xbase_Types_CommonSuperType</a>. The set of types from which the common super type is 
computed corresponds to the types of each case&apos;s result expression. In case a switch expression&apos;s type is
computed using the expected type from the context, it is sufficient to return the expected type if all case branches types conform to the expected type.
</p>
<a name="Xtend_Expressions_SwitchExpression_9"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">switch</span>&nbsp;foo&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;Entity&nbsp;:&nbsp;foo.superType.name<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;Datatype&nbsp;:&nbsp;foo.name<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;throw&nbsp;new&nbsp;IllegalStateException<br/>
		}<br/>
		</p>
		</div>
		</div>
		
	</li>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">switch</span>&nbsp;x&nbsp;:&nbsp;foo.bar.complicated(<span class="string">&apos;hello&apos;</span>,42)&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="string">"hello42"</span>&nbsp;:&nbsp;...<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;x.length&lt;2&nbsp;:&nbsp;...<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;....<br/>
		}<br/>
		</p>
		</div>
		</div>
		
	</li>
</ul>
</p>
<a name="Xtend_Expressions_SwitchExpression_10"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XSwitchExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;switch&apos;</span>&nbsp;(ID&nbsp;<span class="string">&apos;:&apos;</span>)?&nbsp;XExpression&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XCasePart+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;default&apos;</span>&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;XExpression))?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;}&apos;</span>;<br/>
<br/>
XCasePart:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;JvmTypeReference?&nbsp;(<span class="string">&apos;case&apos;</span>&nbsp;XExpression)?&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;XExpression&nbsp;);<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_VariableDeclaration"></a>
<h3>Variable Declarations</h3>
<p>
Variable declarations are only allowed within <a href="03-Xtend_Expressions.html#Xtend_Expressions_Blocks" title="Go to &quot;Blocks&quot;">blocks</a>. They are visible in any subsequent expressions in
the block. Although overriding or shadowing variables from outer scopes is allowed, it is usually only
used to overload the variable name &apos;this&apos;, in order to subsequently access an object&apos;s features in an
unqualified manner.
</p>
<p>
A variable declaration starting with the keyword <span class="inlinecode">val</span> denotes a so called value, which is essentially a final (i.e. unsettable) variable. In rare cases, one
needs to update the value of a reference. In such situations the variable needs to be declared with the keyword <span class="inlinecode">var</span>, which stands for &apos;variable&apos;.
</p>
<p>
A typical example for using <span class="inlinecode">var</span> is a counter in a loop. 
<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;max&nbsp;=&nbsp;100<br/>
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;=&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&nbsp;&gt;&nbsp;max)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<span class="string">"Hi&nbsp;there!"</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Variables declared outside a closure using the <span class="inlinecode">var</span> keyword are not accessible from within a
closure.
</p>
<a name="Xtend_Expressions_VariableDeclaration_5"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XVariableDeclaration:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;val&apos;</span>&nbsp;|&nbsp;<span class="string">&apos;var&apos;</span>)&nbsp;JvmTypeReference?&nbsp;ID&nbsp;<span class="string">&apos;=&apos;</span>&nbsp;XExpression;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_VariableDeclaration_6"></a>
<h4>Typing</h4>
<p>
The return type of a variable declaration expression is always <span class="inlinecode">void</span>. 
The type of the variable itself can either be explicitly declared or be inferred from the right hand side expression.
Here is an example for an explicitly declared type:
<div class="literallayout">
<div class="incode">
<p class="code">
var&nbsp;List&lt;String&gt;&nbsp;msg&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();&nbsp;<br/>
</p>
</div>
</div>

In such cases, the right hand expression&apos;s type must <a href="199g-xbase-language-reference-types.html#Xbase_Types_ConformanceRules" title="Go to &quot;Conformance and Conversion&quot;">conform</a> to the type on the left hand side. 
</p>
<p>
Alternatively the type can be left out and will be inferred from the initialization expression:  
<div class="literallayout">
<div class="incode">
<p class="code">
var&nbsp;msg&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();&nbsp;<span class="comment">//&nbsp;-&gt;&nbsp;type&nbsp;ArrayList&lt;String&gt;&nbsp;&nbsp;<br/>
</span>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_Blocks"></a>
<h3>Blocks</h3>
<p>
The block expression allows to have imperative code sequences. It consists of a sequence of expressions, and returns the value of the last expression.
The return type of a block is also the type of the last expression. Empty blocks return <span class="inlinecode">null</span>. 
<a href="03-Xtend_Expressions.html#Xtend_Expressions_VariableDeclaration" title="Go to &quot;Variable Declarations&quot;">Variable declarations</a> are only allowed within blocks and cannot be used as a block&apos;s last expression.
</p>
<p>
A block expression is surrounded by curly braces and contains at least one expression.
It can optionally be terminated by a semicolon.
</p>
<a name="Xtend_Expressions_Blocks_3"></a>
<h4>Examples</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(<span class="string">"foo"</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result<br/>
}<br/>
</p>
</div>
</div>

<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;x&nbsp;=&nbsp;greeting();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(x.equals(<span class="string">"Hello&nbsp;"</span>))&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x+<span class="string">"World!"</span>;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_Blocks_4"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XBlockExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(XExpressionInsideBlock&nbsp;<span class="string">&apos;;&apos;</span>?)*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;}&apos;</span>;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_ForLoop"></a>
<h3>For Loop</h3>
<p>
The for loop <span class="inlinecode">for&nbsp;(T1&nbsp;variable&nbsp;:&nbsp;iterableOfT1)&nbsp;expression</span> is used to execute a certain expression for each element of an
array of an instance of <span class="inlinecode">java.lang.Iterable</span>.
The local <span class="inlinecode">variable</span> is final, hence canot be updated. 
</p>
<p>
The return type of a for loop is <span class="inlinecode">void</span>.
The type of the local variable can be left out. In that case it is inferred from the type of the array
or <span class="inlinecode">java.lang.Iterable</span> returned by the iterable expression.
</p>
<p>
<ul>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		for&nbsp;(String&nbsp;s&nbsp;:&nbsp;myStrings)&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(s);<br/>
		}<br/>
		</p>
		</div>
		</div>
		
	</li>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		for&nbsp;(s&nbsp;:&nbsp;myStrings)<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(s)<br/>
		</p>
		</div>
		</div>
		
	</li>
</ul>
</p>
<a name="Xtend_Expressions_ForLoop_4"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XForExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;for&apos;</span>&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;JvmFormalParameter&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;XExpression&nbsp;<span class="string">&apos;)&apos;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XExpression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_WhileExpression"></a>
<h3>While Loop</h3>
<p>
A while loop <span class="inlinecode">while&nbsp;(predicate)&nbsp;expression</span> is used to execute a certain expression unless the predicate is evaluated to <span class="inlinecode"><span class="keyword">false</span></span>.
The return type of a while loop is <span class="inlinecode">void</span>.
</p>
<a name="Xtend_Expressions_WhileExpression_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XWhileExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;while&apos;</span>&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;predicate=XExpression&nbsp;<span class="string">&apos;)&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=XExpression;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_WhileExpression_3"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		while&nbsp;(<span class="keyword">true</span>)&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(<span class="string">"foo"</span>);<br/>
		}<br/>
		</p>
		</div>
		</div>
	</li>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		while&nbsp;(&nbsp;(&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1&nbsp;)&nbsp;&lt;&nbsp;max&nbsp;)&nbsp;<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(&nbsp;<span class="string">"foo"</span>&nbsp;)<br/>
		</p>
		</div>
		</div>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_DoWhileExpression"></a>
<h3>Do-While Loop</h3>
<p>
A do-while loop <span class="inlinecode">do&nbsp;expression&nbsp;while&nbsp;(predicate)</span> is used to execute a certain expression unless the predicate is evaluated to <span class="inlinecode"><span class="keyword">false</span></span>.
The difference to the <a href="03-Xtend_Expressions.html#Xtend_Expressions_WhileExpression" title="Go to &quot;While Loop&quot;">while loop</a> is that the execution starts by executing the block once before evaluating the predicate for the first time.
The return type of a do-while loop is <span class="inlinecode">void</span>.
</p>
<a name="Xtend_Expressions_DoWhileExpression_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XDoWhileExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;do&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=XExpression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;while&apos;</span>&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;predicate=XExpression&nbsp;<span class="string">&apos;)&apos;</span>;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_DoWhileExpression_3"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		do&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(<span class="string">"foo"</span>);<br/>
		}&nbsp;while&nbsp;(<span class="keyword">true</span>)<br/>
		</p>
		</div>
		</div>
	</li>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		do&nbsp;doSideEffect(<span class="string">"foo"</span>)&nbsp;while&nbsp;((i=i+1)&lt;max)<br/>
		</p>
		</div>
		</div>
	</li>
</ul>
</p>
<a name="Xtend_Expressions_Return"></a>
<h3>Return Expression</h3>
<p>
Although an explicit return is often not necessary, it is supported.
In a closure for instance a return expression is always implied if the expression itself is not of type
<span class="inlinecode">void</span>. Anyway you can make it explicit:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
listOfStrings.map(e|&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(e==null)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;<span class="string">"NULL"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;e.toUpperCase<br/>
})&nbsp;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_Throw"></a>
<h3>Throwing Exceptions</h3>
<p>
Like in Java it is possible to throw <span class="inlinecode">java.lang.Throwable</span>. The syntax is exactly the same as in Java.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(myList.isEmpty)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(<span class="string">"the&nbsp;list&nbsp;must&nbsp;not&nbsp;be&nbsp;empty"</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...<br/>
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_Expressions_TryCatch"></a>
<h3>Try, Catch, Finally</h3>
<p>
The try-catch-finally expression is used to handle exceptional situations.
You are not forced to declare checked exceptions, if you don&apos;t catch checked exceptions they are rethrown
in a wrapping runtime exception. 
Other than that the syntax again is like the one known from Java.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
try&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException()<br/>
}&nbsp;catch&nbsp;(NullPointerException&nbsp;e)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;handle&nbsp;e<br/>
</span>}&nbsp;finally&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;do&nbsp;stuff<br/>
</span>}<br/>
</p>
</div>
</div>
</p>
<a name="Xtend_RichStrings"></a>
<h3>Rich Strings</h3>
<p>
Rich Strings allow for readable string concatenation, which is the main thing you do when writing a code generator. 
Let&apos;s have a look at an example of how a typical function with template expressions looks like:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
toClass(Entity&nbsp;e)&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;<br/>
&nbsp;&nbsp;package&nbsp;&laquo;e.packageName&raquo;;<br/>
<br/>
&nbsp;&nbsp;&laquo;placeImports&raquo;<br/>
<br/>
&nbsp;&nbsp;public&nbsp;class&nbsp;&laquo;e.name&raquo;&nbsp;&laquo;IF&nbsp;e.extends!=null&raquo;extends&nbsp;&laquo;e.extends&raquo;&laquo;ENDIF&raquo;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&laquo;FOR&nbsp;e.members&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;member.toMember&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&laquo;ENDFOR&raquo;<br/>
&nbsp;&nbsp;}<br/>
&apos;</span><span class="string">&apos;&apos;</span><br/>
</p>
</div>
</div>
</p>
<p>
If you are familiar with Xpand, you&apos;ll notice that it is exactly the same syntax. The difference is, that
the template syntax is actually an expression, which means it can occur everywhere where an expression is
expected. For instance in conjunction the powerful <a href="03-Xtend_Expressions.html#Xtend_Expressions_SwitchExpression" title="Go to &quot;Switch Expression&quot;">switch expression</a>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
toMember(Member&nbsp;m)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span>&nbsp;m&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Field&nbsp;:&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;private&nbsp;&laquo;m.type&raquo;&nbsp;&laquo;m.name&raquo;&nbsp;;&apos;</span><span class="string">&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;<span class="keyword">case</span>&nbsp;isAbstract&nbsp;:&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;&nbsp;abstract&nbsp;&laquo;...&apos;</span><span class="string">&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;:&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;&nbsp;.....&nbsp;&apos;</span><span class="string">&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="RichStringIF"></a>
<h3>Conditions in Rich Strings</h3>
<p>
There is a special <span class="inlinecode">IF</span> to be used within rich strings which is identical in syntax and meaning to the
old <span class="inlinecode">IF</span> from Xpand. Note that you could also use the if expression, but since it has not an explicit
terminal token, it is not as readable in that context.
</p>
<a name="RichStringFOREACH"></a>
<h3>Loops in Rich Strings</h3>
<p>
Also the <span class="inlinecode">FOR</span> statement is available and can only be used in the context of a rich string.
It also supports the <span class="inlinecode">SEPARATOR</span> from Xpand. In addition, a <span class="inlinecode">BEFORE</span> expression
can be defined that is only evaluated if the loop is at least evaluated once before the very first iteration.
Consequently <span class="inlinecode">AFTER</span> is evaluated after the last iteration if there is any element.
</p>
<a name="RichStringType"></a>
<h3>Typing</h3>
<p>
The rich string is translated to an efficient string concatenation and the return type of a rich string
is <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/CharSequence.html" title="View JavaDoc"><abbr title="java.lang.CharSequence" >CharSequence</abbr></a> which allows room for efficient implementation.
</p>
<a name="WhitespaceHandling"></a>
<h3>White Space Handling</h3>
<p>
One of the key features of rich strings is the smart handling of white space in the template output. The
white space is not written into the output data structure as is but preprocessed. This allows for readable
templates as well as nicely formatted output. This can be achieved by applying three simple rules
when the rich string is evaluated.
</p>
<p>
<ol>
	<li>
		
				An evaluated rich string as part of another string will be prefixed with the current indentation
				of the caller before it is inserted into the result.
	</li>
	<li>
		
				Indentation in the template that is relative to a control structure will not be propagated to
				the output string. A control structure is a <span class="inlinecode">FOR</span>-loop or a condition (<span class="inlinecode">IF</span>) as well
				as the opening and closing marks of the rich string itself.
				
				The indentation is considered to be relative to such a control structure if the previous line
				ends with a control structure followed by optional white space. The amount of white space is not
				taken into account but the delta to the other lines.
	</li>
	<li>
		
				Lines that do not contain any static text which is not white space but do contain control structures
				or invocations of other templates which evaluate to an empty string, will not appear in the output.
	</li>
</ol>
</p>
<p>
The behavior is best described with a set of examples. The following table assumes a data structure of
nested nodes.
</p>
<p>
<table>
<tr>
<td>

			<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;Template&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;print(Node&nbsp;n)&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;&laquo;n.name&raquo;&nbsp;{}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&apos;</span><span class="string">&apos;&apos;</span><br/>
}<br/>
</p>
</div>
</div>

</td>
<td>

			<div class="literallayout">
<div class="incode">
<p class="code">
node&nbsp;NodeName{}<br/>
</p>
</div>
</div>

</td>
</tr>
</table>
</p>
<p>
The indentation before <span class="inlinecode">node&nbsp;&laquo;n.name&raquo;</span> will be skipped as it is relative to the opening
mark of the rich string and thereby not considered to be relevant for the output but only
for readability of the template itself.
</p>
<p>
<table>
<tr>
<td>

			<div class="literallayout">
<div class="incode">
<p class="code">
class&nbsp;Template&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;print(Node&nbsp;n)&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;&laquo;n.name&raquo;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;IF&nbsp;hasChildren&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;n.children*.print&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;ENDIF&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&apos;</span><span class="string">&apos;&apos;</span><br/>
}<br/>
</p>
</div>
</div>

</td>
<td>

			<div class="literallayout">
<div class="incode">
<p class="code">
node&nbsp;Parent{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;FirstChild&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;SecondChild&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;Leaf&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>

</td>
</tr>
</table>
</p>
<p>
As in the previous example, there is no indentation on the root level for the same reason.
The first nesting level has only one indentation level in the output. This is derived from
the indentation of the <span class="inlinecode">IF&nbsp;hasChildren</span> condition in the template which is nested in
the node. The additional nesting of the recursive invocation <span class="inlinecode">children*.print</span> is not
visible in the output as it is relative the the surrounding control structure. The line with
<span class="inlinecode">IF</span> and <span class="inlinecode">ENDIF</span> contain only control structures thus they are skipped in the output.
Note the additional indentation of the node <em>Leaf</em> which happens due to the first rule:
Indentation is propagated to called templates.
</p>
</body>
</html>

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Xtext and Java</title>

<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="index.html" title="">
</head>
<body>
<a name="Xbase"></a>
<h1>Xtext and Java</h1>
<p>
The following chapter demonstrates how to integrate your own DSL with Java. We will do this in four
stages: First, you will learn how to refer to existing Java elements from within your language. Then
you will use Xbase to refer to generic types. In the third step, you will map your own DSL&apos;s concepts 
to Java concepts. Last but not least, you will use both Java types and your concepts within Xbase 
expressions and execute it. 
</p>
<p>
Throughout this chapter, we will step by step improve the <a href="030-tutorial-next-steps.html" title="Go to &quot;15 Minutes Tutorial - Extended&quot;">domain model example from the tutorial</a>.  
</p>
<a name="Xbase_3"></a>
<h2>Plug-in Setup</h2>
<p>
In the following, we are going to use the JVM types model and the Xbase language library. To make these
available to your language, you have to add a couple of dependencies. In the runtime plug-in of your
language, add dependencies to   
</p>
<p>
<ul>
	<li>
		<em>org.eclipse.xtext.common.types</em>
	</li>
	<li>
		<em>org.eclipse.xtext.xbase</em> and
	</li>
	<li>
		<em>org.eclipse.xtext.xtend2.lib</em> if you are using Xtend to implement components.
	</li>
</ul>
</p>
<p>
Your UI plug-in needs dependencies to
<ul>
	<li>
		<em>org.eclipse.xbase.ui</em>
	</li>
	<li>
		<em>org.eclipse.xtext.common.types.ui</em>
	</li>
</ul>
</p>
<p>
Additionally, you have to register the <em>genmodel</em> of Xbase to the standalone setup of your MWE2 workflow
and make sure the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/generator/types/TypesGeneratorFragment.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.types.TypesGeneratorFragment" >TypesGeneratorFragment</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/types/TypesGeneratorFragment.java" title="View Source Code" >(src)</a> and the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.xbase.XbaseGeneratorFragment" >XbaseGeneratorFragment</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.java" title="View Source Code" >(src)</a> are included:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
bean&nbsp;=&nbsp;StandaloneSetup&nbsp;{<br/>
&nbsp;&nbsp;registerGenModelFile&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"platform:/resource/org.eclipse.xtext.xbase/model/Xbase.genmodel"</span><br/>
}<br/>
...<br/>
fragment&nbsp;=&nbsp;types.TypesGeneratorFragment&nbsp;{}<br/>
fragment&nbsp;=&nbsp;xbase.XbaseGeneratorFragment&nbsp;{}<br/>
</p>
</div>
</div>
</p>
<p>
To avoid running out of memory when regenerating, you increase the maximum heap size and the permanent generation
space in the run configuration of your workflow. We recommend at least 
</p>
<p>
<span class="inlinecode">-Xmx512m&nbsp;-XX:MaxPermSize=128m</span> 
</p>
<p>
in the <em>VM Arguments</em> section of the <em>Arguments</em> tab. If you are experiencing ambiguity warnings from Antlr,
the <a href="020-grammar-language.html#antlr_errors" title="Go to &quot;Syntactic Predicates&quot;">usual countermeasures</a> apply.
</p>
<a name="jvmtypes"></a>
<h2>Referring to Java Elements using JVM Types</h2>
<p>
A common use case when developing languages is the requirement to refer to existing concepts of other 
languages. Xtext makes this very easy for other self defined DSLs. However, it is often very useful
to have access to the available types of the Java Virtual Machine. The JVM types Ecore model enables
clients to do exactly this. It is possible to create cross-references to classes, interfaces, and their 
fields and methods. Basically every information about the structural concepts of the Java type system
is available via the JVM types. This includes annotations and their specific values and enumeration 
literals as well.
</p>
<p>
The implementation will be selected transparently depending on how the client code is 
executed. If the environment is a plain stand-alone Java or OSGi environment, the <em>java.lang.reflect</em> 
API will be used to deduce the necessary data. On the contrary, the type-model will be created from the 
live data of the JDT in an interactive Eclipse environment. All this happens transparently for the clients
behind the scenes via different implementations that are bound to specific interfaces by means of Google Guice. 
</p>
<p>
Using the JVM types model is very simple. First of all, the grammar has to import the <em>JavaVMTypes</em> Ecore model. 
Thanks to content assist this is easy to spot in the list of proposals.  
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">import</span>&nbsp;<span class="string">"http://www.eclipse.org/xtext/common/JavaVMTypes"</span>&nbsp;<span class="keyword">as</span>&nbsp;jvmTypes<br/>
</p>
</div>
</div>
</p>
<p>
The next step is to actually refer to an imported concept. Let&apos;s define a mapping to available
Java types for the simple data types in the domain model language. This can be done with a simple cross-reference:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="comment">//&nbsp;simple&nbsp;cross&nbsp;reference&nbsp;to&nbsp;a&nbsp;Java&nbsp;type<br/>
</span>DataType:<br/>
&nbsp;&nbsp;<span class="string">&apos;datatype&apos;</span>&nbsp;name=ID&nbsp;<br/>
&nbsp;&nbsp;<span class="string">&apos;mapped-to&apos;</span>&nbsp;javaType=[jvmTypes::JvmType|QualifiedName];<br/>
</p>
</div>
</div>
</p>
<p>
After regenerating your language, it will be allowed to define a type <span class="inlinecode">Date</span> that maps to the <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Date.html" title="View JavaDoc"><abbr title="java.util.Date" >Date</abbr></a>
like this:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">datatype</span>&nbsp;Date&nbsp;<span class="keyword">mapped-to</span>&nbsp;java.util.Date<br/>
</p>
</div>
</div>
</p>
<p>
These two steps will provide a nice integration into the Eclipse JDT. There is <em>Find References</em> on Java methods, 
fields and types that will reveal results in your language files. <em>Go To Declaration</em> works as expected
and content assist will propose the list of available types. Even the <em>import</em> statements will also
apply for Java types. 
</p>
<a name="jvmtypes_10"></a>
<h3>Customization Points</h3>
<p>
There are several customization hooks in the runtime layer of the JVM types and on the editor side as well:
</p>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/xtext/AbstractTypeScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.xtext.AbstractTypeScopeProvider" >AbstractTypeScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/xtext/AbstractTypeScopeProvider.java" title="View Source Code" >(src)</a> 
can be used to create scopes for members with respect to
the override semantics of the Java language. Of course it is possible to use this implementation to
create scopes for types as well.
</p>
<p>
As the Java VM types expose a lot of information about visibility, parameter- and return types, generics,
available annotations or enumeration literals, it is very easy to define constraints for the referred types.
</p>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/xtext/ui/ITypesProposalProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.xtext.ui.ITypesProposalProvider" >ITypesProposalProvider</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/xtext/ui/ITypesProposalProvider.java" title="View Source Code" >(src)</a> can be
used to provide optimized proposals based on various filter criteria. 
The most common selector can be used directly via <span class="inlinecode">createSubTypeProposals(..)</span>. The implementation is optimized
and uses the JDT Index directly to minimize the effort for object instantiation. The class 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/xtext/ui/TypeMatchFilters.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.xtext.ui.TypeMatchFilters" >TypeMatchFilters</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/xtext/ui/TypeMatchFilters.java" title="View Source Code" >(src)</a>
provides a comprehensive set of reusable filters that can be easily combined to reduce the list of proposals
to a smaller number of valid entries.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">import</span>&nbsp;<span class="keyword">static</span>&nbsp;org.eclipse.xtext.common.types.xtext.ui.TypeMatchFilters;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<span class="comment">//&nbsp;..<br/>
</span>&nbsp;&nbsp;proposalProvider.createSubTypeProposals(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;superType,&nbsp;factory,&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MyDslPackage.Literals.TYPE__MAPPED_TO,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TypeMatchFilters.and(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TypeMatchFilters.not(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TypeMatchFilters.canInstantiate()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TypeMatchFilters.isPublic()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;),&nbsp;acceptor);<br/>
</p>
</div>
</div>

</p>
<a name="xbaseJavaReferences"></a>
<h2>Referring to Java Types Using Xbase</h2>
<p>
While the JVM types approach from the last chapter allow to refer to any Java element, it has its drawbacks
when it comes to generics. Usually, a type reference in Java can have type arguments which can also include
wildcards, upper and lower bounds etc. A simple cross-reference using a qualified name is not enough
to express neither the syntax nor the structure of such a type reference. 
</p>
<p>
Xbase offers a parser rule <em>JvmTypeReference</em> which supports the full syntax of a Java type reference
and instantiates an JVM element of type <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/JvmTypeReference.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmTypeReference" >JvmTypeReference</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/JvmTypeReference.java" title="View Source Code" >(src)</a>. So
lets start by letting our language inherit from Xbase
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;org.eclipse.xtext.example.Domainmodel&nbsp;<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.xbase.Xbase<br/>
</p>
</div>
</div>
</p>
<p>
As we can express all kinds of Java type references directly now, the indirection for <em>DataTypes</em> 
no longer makes sense. Let us turn all cross-references to <em>Types</em> to calls to the <em>JvmTypeReferences</em>
rule. The rules <em>DataType</em>, <em>Type</em>, and <em>QualifiedName</em> become obsolete (the latter is already defined
in Xbase), and the <em>Type</em> in <em>AbstractEntity</em> must be changed to <em>Entity</em>. The whole grammar now reads
as
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;org.eclipse.xtext.example.Domainmodel&nbsp;<span class="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.eclipse.xtext.xbase.Xbase<br/>
<br/>
<span class="keyword">generate</span>&nbsp;domainmodel&nbsp;<span class="string">"http://www.eclipse.org/xtext/example/Domainmodel"</span><br/>
<span class="keyword">import</span>&nbsp;<span class="string">"http://www.eclipse.org/xtext/common/JavaVMTypes"</span>&nbsp;<span class="keyword">as</span>&nbsp;jvmTypes<br/>
<br/>
Domainmodel:<br/>
&nbsp;&nbsp;(elements&nbsp;+=&nbsp;AbstractElement)*<br/>
;<br/>
<br/>
PackageDeclaration:<br/>
&nbsp;&nbsp;<span class="string">&apos;package&apos;</span>&nbsp;name&nbsp;=&nbsp;QualifiedName&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(elements&nbsp;+=&nbsp;AbstractElement)*<br/>
&nbsp;&nbsp;<span class="string">&apos;}&apos;</span><br/>
;<br/>
<br/>
AbstractElement:<br/>
&nbsp;&nbsp;PackageDeclaration&nbsp;|&nbsp;Entity&nbsp;|&nbsp;Import<br/>
;<br/>
<br/>
Import:<br/>
&nbsp;&nbsp;<span class="string">&apos;import&apos;</span>&nbsp;importedNamespace&nbsp;=&nbsp;QualifiedNameWithWildcard<br/>
;<br/>
&nbsp;&nbsp;<br/>
QualifiedNameWithWildcard:<br/>
&nbsp;&nbsp;QualifiedName&nbsp;<span class="string">&apos;.*&apos;</span>?<br/>
;<br/>
&nbsp;&nbsp;<br/>
Entity:<br/>
&nbsp;&nbsp;<span class="string">&apos;entity&apos;</span>&nbsp;name&nbsp;=&nbsp;ID&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;extends&apos;</span>&nbsp;superType&nbsp;=&nbsp;JvmTypeReference)?<br/>
&nbsp;&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(features&nbsp;+=&nbsp;Feature)*<br/>
&nbsp;&nbsp;<span class="string">&apos;}&apos;</span><br/>
;<br/>
&nbsp;<br/>
Feature:<br/>
&nbsp;&nbsp;(many&nbsp;?=&nbsp;<span class="string">&apos;many&apos;</span>)?&nbsp;name&nbsp;=&nbsp;ID&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;type&nbsp;=&nbsp;JvmTypeReference<br/>
;&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
As we changed the grammar, we have to regenerate the language now.
</p>
<p>
Being able to parse a Java type reference is good, but we also have to write them back to their string
representation when we generate Java code. Into the bargain, a generic type reference with fully qualified
class names can become a bit bulky. The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/compiler/ImportManager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.ImportManager" >ImportManager</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ImportManager.java" title="View Source Code" >(src)</a> shortens
fully qualified names, keeps track of imported namespaces, avoids name collisions, and serializes
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/JvmTypeReference.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmTypeReference" >JvmTypeReferences</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/JvmTypeReference.java" title="View Source Code" >(src)</a>.
</p>
<p>
The following snippet shows our code generator using an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/compiler/ImportManager.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.ImportManager" >ImportManager</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ImportManager.java" title="View Source Code" >(src)</a>.
We create a new instance and pass it through the generation functions, collecting types on the way. As
the import section in a Java file precedes the class body, we create the body into a String variable
and assemble the whole file&apos;s content in a second step.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;DomainmodelGenerator&nbsp;<span class="keyword">implements</span>&nbsp;IGenerator&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;IQualifiedNameProvider&nbsp;nameProvider<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">override</span>&nbsp;<span class="keyword">void</span>&nbsp;doGenerate(Resource&nbsp;resource,&nbsp;IFileSystemAccess&nbsp;fsa)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>(e:&nbsp;resource.allContentsIterable.filter(<span class="keyword">typeof</span>(Entity)))&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsa.generateFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.fullyQualifiedName.toString.replace(<span class="string">"."</span>,&nbsp;<span class="string">"/"</span>)&nbsp;+&nbsp;<span class="string">".java"</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.compile)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;compile(Entity&nbsp;e)&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;val&nbsp;importManager&nbsp;=&nbsp;new&nbsp;ImportManager(true)&raquo;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;val&nbsp;body&nbsp;=&nbsp;body(e,&nbsp;importManager)&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;IF&nbsp;e.eContainer&nbsp;!=&nbsp;null&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;package&nbsp;&laquo;e.eContainer.fullyQualifiedName&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;ENDIF&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;FOR&nbsp;i:importManager.imports&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import&nbsp;&laquo;i&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;ENDFOR&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;body&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&apos;</span><span class="string">&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;body(Entity&nbsp;e,&nbsp;ImportManager&nbsp;importManager)&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;&laquo;e.name&raquo;&nbsp;&laquo;IF&nbsp;e.superType&nbsp;!=&nbsp;null&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extends&nbsp;&laquo;e.superType.shortName(importManager)&raquo;&nbsp;&laquo;ENDIF&raquo;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;FOR&nbsp;f:e.features&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;f.compile(importManager)&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;ENDFOR&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&apos;</span><span class="string">&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;compile(Feature&nbsp;f,&nbsp;ImportManager&nbsp;importManager)&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;&laquo;f.type.shortName(importManager)&raquo;&nbsp;&laquo;f.name&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&laquo;f.type.shortName(importManager)&raquo;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get&laquo;f.name.toFirstUpper&raquo;()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&laquo;f.name&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;set&laquo;f.name.toFirstUpper&raquo;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;f.type.shortName(importManager)&raquo;&nbsp;&laquo;f.name&raquo;)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.&laquo;f.name&raquo;&nbsp;=&nbsp;&laquo;f.name&raquo;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&apos;</span><span class="string">&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;shortName(JvmTypeReference&nbsp;typeRef,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImportManager&nbsp;importManager)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;result&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;StringBuilder()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;importManager.appendTypeRef(typeRef,&nbsp;result)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.toString<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="xbaseInferredType"></a>
<h2>Inferring a JVM Model</h2>
<p>
In many cases, you will want your DSLs concepts to be usable as Java elements. E.g. an <em>Entity</em> will
become a Java class and should be usable as such. In the domain model example, you can write  
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">entity</span>&nbsp;Employee&nbsp;<span class="keyword">extends</span>&nbsp;Person&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boss:&nbsp;Person<br/>
...<br/>
<br/>
<span class="keyword">entity</span>&nbsp;Person&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;friends:&nbsp;List&lt;Person&gt;<br/>
...<br/>
</p>
</div>
</div>
</p>
<p>
i.e. use entities instead of Java types or even mix Java types as <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html" title="View JavaDoc"><abbr title="java.util.List" >List</abbr></a> with entities such as <em>Person</em>.
One way to achieve this is to let your concepts inherit from a corresponding JVM type, e.g. let <em>Entity</em>
inherit from <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/JvmGenericType.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmGenericType" >JvmGenericType</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/JvmGenericType.java" title="View Source Code" >(src)</a>. But this would result in a lot of 
accidentally inherited properties in your domain model. In Xbase there is an alternative: You can define how
to derive a JVM model from your model. This <em>inferred JVM model</em> is the representation of your concepts
in the typesystem of Xbase.  
</p>
<p>
The main component for the inferred JVM model is the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer" >IJvmModelInferrer</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java" title="View Source Code" >(src)</a>.
It has a single method that gets a model element passed in and returns a list of 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/JvmGenericType.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmGenericType" >JvmGenericTypes</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/JvmGenericType.java" title="View Source Code" >(src)</a>. As Xbase cannot guess how you
would like to map your concepts to JVM elements, you have to implement this component yourself. This
usually boils down to use an injected <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/TypesFactory.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.TypesFactory" >TypesFactory</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/TypesFactory.java" title="View Source Code" >(src)</a> to create
a hierarchy of JVM elements, initialize that with values from the input model, and eventually use an injected
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociator" >IJvmModelAssociator</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociator.java" title="View Source Code" >(src)</a> to associate the model elements with the
JVM elements. As this kind of transformation can be elegantly implemented using polymorphic dispatch
functions and extension methods, it is a good choice to write the 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer" >IJvmModelInferrer</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java" title="View Source Code" >(src)</a> in Xtend.
</p>
<p>
For our domain model example, we call a recursive polymorphic dispatch function <em>transform</em> to traverse
the containment hierarchy of the source model and generate JVM elements on the way. We transform each
<em>Entity</em> to a <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/JvmGenericType.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmGenericType" >JvmGenericType</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/JvmGenericType.java" title="View Source Code" >(src)</a> that holds a 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/JvmOperation.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmOperation" >JvmOperation</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/JvmOperation.java" title="View Source Code" >(src)</a> for each <em>Operation</em> and a 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/JvmField.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmField" >JvmField</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/JvmField.java" title="View Source Code" >(src)</a> plus access methods for each <em>Property</em>. Whenever
we have to copy a subtree, e.g. for setting the supertype of the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/JvmGenericType.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmGenericType" >JvmGenericType</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/JvmGenericType.java" title="View Source Code" >(src)</a>,
we use <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/EcoreUtil2.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.EcoreUtil2" >EcoreUtil2</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/EcoreUtil2.java" title="View Source Code" >(src)</a> <em>.cloneWithProxies()</em> to avoid eager resolution of referenced
types. The resulting <em>DomainmodelJvmModelInferrer</em> looks like this:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;DomainmodelJvmModelInferrer&nbsp;<span class="keyword">implements</span>&nbsp;IJvmModelInferrer&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;@Inject&nbsp;TypesFactory&nbsp;typesFactory<br/>
&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;IJvmModelAssociator&nbsp;jvmModelAssociator<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">override</span>&nbsp;List&lt;JvmDeclaredType&gt;&nbsp;inferJvmModel(EObject&nbsp;sourceObject)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceObject.disassociate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform(&nbsp;sourceObject&nbsp;).toList<br/>
&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">dispatch</span>&nbsp;Iterable&lt;JvmDeclaredType&gt;&nbsp;transform(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Domainmodel&nbsp;model)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model.elements.map(e&nbsp;|&nbsp;transform(e)).flatten<br/>
&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">dispatch</span>&nbsp;Iterable&lt;JvmDeclaredType&gt;&nbsp;transform(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PackageDeclaration&nbsp;packageDecl)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packageDecl.elements.map(e&nbsp;|&nbsp;transform(e)).flatten<br/>
&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">dispatch</span>&nbsp;Iterable&lt;JvmDeclaredType&gt;&nbsp;transform(Entity&nbsp;entity)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;jvmClass&nbsp;=&nbsp;typesFactory.createJvmGenericType&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmClass.simpleName&nbsp;=&nbsp;entity.name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmClass.packageName&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(entity.eContainer&nbsp;<span class="keyword">as</span>&nbsp;PackageDeclaration).name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.associatePrimary(jvmClass)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmClass.visibility&nbsp;=&nbsp;JvmVisibility::PUBLIC<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(entity.superType&nbsp;!=&nbsp;null)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmClass.superTypes&nbsp;+=&nbsp;cloneWithProxies(entity.superType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>(f&nbsp;:&nbsp;entity.features)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform(f,&nbsp;jvmClass)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArrayList(jvmClass&nbsp;<span class="keyword">as</span>&nbsp;JvmDeclaredType)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">dispatch</span>&nbsp;Iterable&lt;JvmDeclaredType&gt;&nbsp;transform(Import&nbsp;i)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emptyList<br/>
&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">void</span>&nbsp;transform(Feature&nbsp;feature,&nbsp;JvmGenericType&nbsp;type)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;jvmField&nbsp;=&nbsp;typesFactory.createJvmField<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmField.simpleName&nbsp;=&nbsp;feature.name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmField.type&nbsp;=&nbsp;cloneWithProxies(feature.type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmField.visibility&nbsp;=&nbsp;JvmVisibility::PRIVATE<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type.members&nbsp;+=&nbsp;jvmField<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feature.associatePrimary(jvmField)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;jvmGetter&nbsp;=&nbsp;typesFactory.createJvmOperation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmGetter.simpleName&nbsp;=&nbsp;<span class="string">"get"</span>&nbsp;+&nbsp;feature.name.toFirstUpper<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmGetter.returnType&nbsp;=&nbsp;cloneWithProxies(feature.type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmGetter.visibility&nbsp;=&nbsp;JvmVisibility::PUBLIC<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type.members&nbsp;+=&nbsp;jvmGetter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feature.associatePrimary(jvmGetter)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;jvmSetter&nbsp;=&nbsp;typesFactory.createJvmOperation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmSetter.simpleName&nbsp;=&nbsp;<span class="string">"set"</span>&nbsp;+&nbsp;feature.name.toFirstUpper<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;parameter&nbsp;=&nbsp;typesFactory.createJvmFormalParameter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameter.name&nbsp;=&nbsp;feature.name.toFirstUpper<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameter.parameterType&nbsp;=&nbsp;cloneWithProxies(feature.type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmSetter.visibility&nbsp;=&nbsp;JvmVisibility::PUBLIC<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmSetter.parameters&nbsp;+=&nbsp;parameter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type.members&nbsp;+=&nbsp;jvmSetter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feature.associatePrimary(jvmSetter)<br/>
&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="xbaseInferredType_7"></a>
<h3>Linking and Indexing</h3>
<p>
As Java elements and your concepts are now represented as JVM model elements, other models can now transparently
link to Java or your DSL. In other words, you can use a mapped element of your DSL in the same places
as the corresponding Java type.
</p>
<p>
The Xbase framework will automatically switch between the JVM element or the DSL element when needed, e.g. when 
following hyperlinks. The component allowing to navigate between the source model and the JVM model is
called <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations" >IJvmModelAssociations</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociations.java" title="View Source Code" >(src)</a>, the read-only antagonist of the
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociator" >IJvmModelAssociator</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelAssociator.java" title="View Source Code" >(src)</a>.
</p>
<p>
By default, the inferred model is <a href="080-scoping.html#global_scopes" title="Go to &quot;Global Scopes and Resource Descriptions&quot;">indexed</a>, so it can be cross referenced from other
models.   
<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=350812">In Xtext 2.0.0</a> you still have to make sure the qualified
names are computed correctly by implementing and binding an appropriate <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/naming/IQualifiedNameProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.naming.IQualifiedNameProvider" >IQualifiedNameProvider</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java" title="View Source Code" >(src)</a>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;DomainmodelQualifiedNameProvider&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">extends</span>&nbsp;DefaultDeclarativeQualifiedNameProvider&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;IQualifiedNameConverter&nbsp;converter;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;QualifiedName&nbsp;qualifiedName(JvmGenericType&nbsp;type)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;converter.toQualifiedName(type.getQualifiedName());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="xbaseInferredType_8"></a>
<h3>Generation Parameters For Inferred JVM Types</h3>
<p>
Several MWE generator fragments have additional properties for the <a href="199c-xbase-inferred-type.html" title="Go to &quot;Inferring a JVM Model&quot;">JVM model inference</a>:
<table>
<tr>
<td>
Fragment
</td>
<td>
Property
</td>
<td>
Purpose
</td>
<td>
Default
</td>
</tr>
<tr>
<td>
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.xbase.XbaseGeneratorFragment" >XbaseGeneratorFragment</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.java" title="View Source Code" >(src)</a>
</td>
<td>
<em>useInferredJvmModel</em>
</td>
<td>
Generate a <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer" >IJvmModelInferrer</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java" title="View Source Code" >(src)</a> stub and hooks for an inferred JVM model
</td>
<td>
<em>true</em>
</td>
</tr>
<tr>
<td>
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.generator.xbase.XbaseGeneratorFragment" >XbaseGeneratorFragment</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/xbase/XbaseGeneratorFragment.java" title="View Source Code" >(src)</a>
</td>
<td>
<em>generateXtendInferrer</em>
</td>
<td>
Generate the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer" >IJvmModelInferrer</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java" title="View Source Code" >(src)</a> stub in Xtend instead of Java
</td>
<td>
<em>true</em>
</td>
</tr>
<tr>
<td>
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/ui/generator/refactoring/RefactorElementNameFragment.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.ui.generator.refactoring.RefactorElementNameFragment" >RefactorElementNameFragment</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/refactoring/RefactorElementNameFragment.java" title="View Source Code" >(src)</a>
</td>
<td>
<em>useJdtRefactoring</em>
</td>
<td>
Always trigger JDT refactoring and register element rename refactoring as a participant thereof
</td>
<td>
<em>false</em>
</td>
</tr>
</table>
</p>
<a name="xbaseExpressions"></a>
<h2>Using Xbase Expressions</h2>
<p>
Xbase is an expression language that can be embedded in Xtext languages. Its syntax is close to Java,
but it additionally offers type inferrence, closures, a rich switch statement and a lot more. For details
on the Xbase langugae itself, please consult the Xbase documentation and the Xbase tutorial. Xbase ships 
with an interpreter and a compiler to Java code. Thus, it is easy to add executable behavior to your DSLs.
As Xbase integrates tightly with Java, there is usually no additional code needed to run your DSL as
part of a Java application. 
</p>
<a name="xbaseExpressions_2"></a>
<h3>Making Your Grammar Refer To Xbase</h3>
<p>
If you want to refer to <a class="jdoc" href="http://download.eclipse.org/modeling/emf/emf/javadoc/2.6.0/org/eclipse/emf/ecore/EClassifier.html" title="View JavaDoc"><abbr title="org.eclipse.emf.ecore.EClassifier" >EClassifiers</abbr></a> from the Xbase model, you need
to import it first. The same holds for the common types model:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">import</span>&nbsp;<span class="string">"http://www.eclipse.org/xtext/xbase/Xbase"</span>&nbsp;<span class="keyword">as</span>&nbsp;xbase<br/>
</p>
</div>
</div>
</p>
<p>
Now identify the location in your grammar, where you want references to Java types and Xbase expression to appear
and call the appropriate rules of the super grammar. <div class="todo" >
</div>
 Have a look at the domainmodel example: An <em>Operation</em>&apos;s 
parameters are <em>JvmFormalParamters</em>, its return type refers to a Java type and its <em>body</em> is
an <em>XBlockExpression</em>, so its parser rule reads as
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Operation:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;visibility=Visibility?&nbsp;<span class="string">&apos;op&apos;</span>&nbsp;name=ValidID&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(params+=JvmFormalParameter&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;params+=JvmFormalParameter)*)?&nbsp;<span class="string">&apos;)&apos;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;type=JvmTypeReference&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=XBlockExpression;<br/>
</p>
</div>
</div>
</p>
<p>
If you&apos;re unsure which entry point to choose for your expressions, consider the root <em>XExpression</em>.
</p>
<p>
To integrate <em>Operations</em> in our models, we have to call this rule. We copy the previous <em>Feature</em>
to a new rule <em>Property</em> and let <em>Feature</em> become the supertype of <em>Property</em> and <em>Operation</em>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Feature:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Property&nbsp;|&nbsp;Operation<br/>
;<br/>
&nbsp;<br/>
Property:<br/>
&nbsp;&nbsp;name&nbsp;=&nbsp;ID&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;type&nbsp;=&nbsp;JvmTypeReference<br/>
;&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
Note: You will have to adapt the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer" >IJvmModelInferrer</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/jvmmodel/IJvmModelInferrer.java" title="View Source Code" >(src)</a> to these
changes, i.e. rename <em>Feature</em> to <em>Property</em> and create a <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/common/types/JvmOperation.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.common.types.JvmOperation" >JvmOperation</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/types/JvmOperation.java" title="View Source Code" >(src)</a>
for each <em>Operation</em>. We leave that as an exercise :-) 
</p>
<a name="xbaseScopeProvider"></a>
<h3>Populating the Scopes</h3>
<p>
If you&apos;re not familiar with Xtext&apos;s concept of scopes yet, it would be a good idea to <a href="080-scoping.html" title="Go to &quot;Scoping&quot;">learn about
scopes</a> before you go on reading this section. 
</p>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/scoping/XbaseScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.scoping.XbaseScopeProvider" >XbaseScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/scoping/XbaseScopeProvider.java" title="View Source Code" >(src)</a> already builds a complex hierarchy of
scopes that is necessary to link your expressions. There are a few points you may want to customize.
</p>
<p>
Within the body of an operation, we want to have several variables on the scope. The variable <em>this</em>
should point to the JVM type of the entity, such that all its features are callable. In addition, the
operation&apos;s parameters should be referrable by their name. The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/scoping/XbaseScopeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.scoping.XbaseScopeProvider" >XbaseScopeProvider</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/scoping/XbaseScopeProvider.java" title="View Source Code" >(src)</a>
has a template method <em>createLocalVarScope</em> for exactly this purpose. The following code shows the Xtend
implementation of the scope provider for our domain model language:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;DomainmodelScopeProvider&nbsp;<span class="keyword">extends</span>&nbsp;XbaseScopeProvider&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;IJvmModelAssociations&nbsp;associations<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">override</span>&nbsp;IScope&nbsp;createLocalVarScope(EObject&nbsp;context,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EReference&nbsp;reference,&nbsp;IScope&nbsp;parent,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">boolean</span>&nbsp;includeCurrentBlock,&nbsp;<span class="keyword">int</span>&nbsp;idx)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(context&nbsp;<span class="keyword">instanceof</span>&nbsp;Entity)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;type&nbsp;=&nbsp;(context&nbsp;<span class="keyword">as</span>&nbsp;Entity).jvmType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;SimpleScope(parent,&nbsp;newImmutableList(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EObjectDescription::<span class="keyword">create</span>(XbaseScopeProvider::THIS,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(context&nbsp;<span class="keyword">instanceof</span>&nbsp;Operation){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;descriptions&nbsp;=&nbsp;(context&nbsp;<span class="keyword">as</span>&nbsp;Operation)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.params.map(e&nbsp;|&nbsp;e.createIEObjectDescription())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;MapBasedScope::createScope(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">super</span>.createLocalVarScope(context,&nbsp;reference,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent,&nbsp;includeCurrentBlock,&nbsp;idx),&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descriptions);&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">super</span>.createLocalVarScope(context,&nbsp;reference,&nbsp;parent,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;includeCurrentBlock,&nbsp;idx)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;createIEObjectDescription(JvmFormalParameter&nbsp;jvmFormalParameter)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EObjectDescription::^create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QualifiedName::^create(jvmFormalParameter.name),&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jvmFormalParameter,&nbsp;null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;JvmType&nbsp;getJvmType(Entity&nbsp;entity)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entity.jvmElements.filter(<span class="keyword">typeof</span>(JvmType)).head<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">override</span>&nbsp;JvmDeclaredType&nbsp;getContextType(EObject&nbsp;call)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(call&nbsp;==&nbsp;null)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;null<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;containerClass&nbsp;=&nbsp;getContainerOfType(call,&nbsp;<span class="keyword">typeof</span>(Entity));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(containerClass&nbsp;!=&nbsp;null)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;getJvmType(containerClass)&nbsp;<span class="keyword">as</span>&nbsp;JvmDeclaredType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">super</span>.getContextType(call)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
In addition to the variable binding and some helper functions, we defined the function <em>getContextType</em>
to tell Xbase, which features are visible (callable) in the context of a the given element. In out case,
these are all features of the inferred type, including the private ones.    
</p>
<a name="xbaseExpressions_4"></a>
<h3>Type Checking at the Boundaries</h3>
<p>
The scope provider from the last section allows Xbase to do static type analysis on the operation bodies,
as all callable properties now have types.  The missing part is to make sure that the declared return type 
conforms to the actual types of the method body&apos;s possible return values.
</p>
<p>
Type analysis in Xbase boils down to compare expected types with the actual types returned by an expression. 
For example, the condition of an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/XIfExpression.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.XIfExpression" >XIfExpression</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/XIfExpression.java" title="View Source Code" >(src)</a>
is expected to be a boolean, so any expression used as condition should conform to the boolean type.
The component the defines these types and expectations is the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/typing/ITypeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.typing.ITypeProvider" >ITypeProvider</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/typing/ITypeProvider.java" title="View Source Code" >(src)</a>. 
It has several responsibilities
</p>
<p>
<table>
<tr>
<td>
getType()
</td>
<td>
returns the type of an expression
</td>
</tr>
<tr>
<td>
getExpectedType()
</td>
<td>
returns the expected type of an expression in a given context
</td>
</tr>
<tr>
<td>
getTypeForIdentifiable()
</td>
<td>
returns the expected type of an element that is referenced
</td>
</tr>
<tr>
<td>
getCommonReturnType()
</td>
<td>
returns the common supertype of all types used in return expressions
	inside this expression
</td>
</tr>
<tr>
<td>
getThrownExceptions()
</td>
<td>
returns the types of all declared exceptions thrown inside this expression
</td>
</tr>
</table>
</p>
<p>
An additional flag <em>rawType</em> signals a raw type without resolved type parameters is enough. This is
needed to avoid cycles in the type inference while linking.
 
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/typing/XbaseTypeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.typing.XbaseTypeProvider" >XbaseTypeProvider</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/typing/XbaseTypeProvider.java" title="View Source Code" >(src)</a> implements polymorphic dispatch methods
for the first three of these. In the domain model example, we expect the return type of the body of an <em>Operation</em>
to conform to the declared return type. We can do so by specializing the default 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/typing/XbaseTypeProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.typing.XbaseTypeProvider" >XbaseTypeProvider</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/typing/XbaseTypeProvider.java" title="View Source Code" >(src)</a> as
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Singleton<br/>
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;DomainmodelTypeProvider&nbsp;<span class="keyword">extends</span>&nbsp;XbaseTypeProvider&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">protected</span>&nbsp;JvmTypeReference&nbsp;_expectedType(Operation&nbsp;operation,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EReference&nbsp;reference,&nbsp;<span class="keyword">int</span>&nbsp;index,&nbsp;<span class="keyword">boolean</span>&nbsp;rawType)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(reference&nbsp;==&nbsp;DomainmodelPackage.Literals.OPERATION__BODY)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;operation.getType();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">null</span>;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
and of course binding this new implementation in the languge&apos;s module. By default, Xbase only checks
type conformance inside expressions. To address the validation at the expression&apos;s boundary, we have
to add a <a href="060-validation.html" title="Go to &quot;Validation&quot;">validation rule</a>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;DomainmodelJavaValidator&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">extends</span>&nbsp;AbstractDomainmodelJavaValidator&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;XbaseTypeConformanceComputer&nbsp;typeConformanceComputer;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;DomainmodelTypeProvider&nbsp;typeProvider;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Check<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;checkTypeConformanceOfOperation(Operation&nbsp;op){<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JvmTypeReference&nbsp;expectedType&nbsp;=&nbsp;typeProvider<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.getExpectedType(op.getBody());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JvmTypeReference&nbsp;commonReturnType&nbsp;=&nbsp;typeProvider<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.getCommonReturnType(op.getBody(),&nbsp;<span class="keyword">true</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(!typeConformanceComputer.isConformant(expectedType,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commonReturnType))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(<span class="string">"Type&nbsp;does&nbsp;not&nbsp;conform&nbsp;to&nbsp;expected&nbsp;type!"</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DomainmodelPackage.Literals.OPERATION__BODY);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="xbaseExpressions_5"></a>
<h3>Generating Java Code using the Xbase Compiler</h3>
<p>
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/compiler/XbaseCompiler.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.XbaseCompiler" >XbaseCompiler</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/XbaseCompiler.java" title="View Source Code" >(src)</a> compiles Xbase expressions to Java code.
You will now learn how to integrate it in the code generator of your DSL. 
</p>
<p>
The following snippet shows how the code generator can call the compiler:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;DomainmodelGenerator&nbsp;<span class="keyword">implements</span>&nbsp;IGenerator&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;DomainmodelCompiler&nbsp;domainmodelCompiler<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">dispatch</span>&nbsp;compile(Operation&nbsp;o,&nbsp;ImportManager&nbsp;importManager)&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&laquo;o.type.shortName(importManager)&raquo;&nbsp;&laquo;o.name&raquo;(&laquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.parameterList(importManager)&raquo;)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&laquo;domainmodelCompiler.compile(o,&nbsp;importManager)&raquo;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&apos;</span><span class="string">&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;parameterList(Operation&nbsp;o,&nbsp;ImportManager&nbsp;importManager)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.params.map(p|&nbsp;p.parameterType.shortName(importManager)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;<span class="string">&apos;&nbsp;&apos;</span>&nbsp;+&nbsp;p.name).join(<span class="string">&apos;&apos;</span><span class="string">&apos;,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&apos;</span><span class="string">&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
Now let us customize the compiler. The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/compiler/XbaseCompiler.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.XbaseCompiler" >XbaseCompiler</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/XbaseCompiler.java" title="View Source Code" >(src)</a> writes its code output into an 
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/compiler/IAppendable.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.IAppendable" >IAppendable</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/IAppendable.java" title="View Source Code" >(src)</a>. This component keeps track of the indentation, 
of local variables, and of the generated code. Use an <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/compiler/StringBuilderBasedAppendable.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.StringBuilderBasedAppendable" >StringBuilderBasedAppendable</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/StringBuilderBasedAppendable.java" title="View Source Code" >(src)</a>
to generate the code of an XbaseExpression into a <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuilder.html" title="View JavaDoc"><abbr title="java.lang.StringBuilder" >StringBuilder</abbr></a>. Before calling the
compiler, we add the operation&apos;s parameters to the local variables. 
</p>
<p>
Remember that in the <a href="199d-xbase-expressions.html#xbaseScopeProvider" title="Go to &quot;Populating the Scopes&quot;">scope provider</a> we bound the variable <em>this</em> to the inferred type of the current <em>Entity</em>. 
The <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/compiler/XbaseCompiler.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.compiler.XbaseCompiler" >XbaseCompiler</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/XbaseCompiler.java" title="View Source Code" >(src)</a> will by default assign the value of all expressions
to a new Java variable. If we just call <em>this</em>, we don&apos;t need that, so we override <em>isVariableDeclarationRequired</em>
to return false in this case. Similarly, whenever the compiler needs to put a variable name for the inferred
Java type, it should use <em>this</em>. This can be achieved by overriding <em>getVarName()</em>. In a similar way,
we have to override the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/featurecalls/IdentifiableSimpleNameProvider.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider" >IdentifiableSimpleNameProvider</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/featurecalls/IdentifiableSimpleNameProvider.java" title="View Source Code" >(src)</a>
to return <em>this</em> for the type. It is likely that we will reduce the last two tasks to one in the future.
</p>
<p>
Here&apos;s the complete code for the customized compiler:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;DomainmodelCompiler&nbsp;<span class="keyword">extends</span>&nbsp;XbaseCompiler&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;String&nbsp;compile(Operation&nbsp;operation,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImportManager&nbsp;importManager)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilderBasedAppendable&nbsp;appendable&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">new</span>&nbsp;StringBuilderBasedAppendable(importManager);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>(JvmFormalParameter&nbsp;param:&nbsp;operation.getParams())&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appendable.declareVariable(param,&nbsp;param.getName());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;compile(operation.getBody(),&nbsp;appendable,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operation.getType()).toString();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Override<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">protected</span>&nbsp;<span class="keyword">boolean</span>&nbsp;isVariableDeclarationRequired(XExpression&nbsp;expr,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IAppendable&nbsp;b)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(expr&nbsp;<span class="keyword">instanceof</span>&nbsp;XAbstractFeatureCall&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;((XAbstractFeatureCall)expr).getFeature()&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">instanceof</span>&nbsp;JvmGenericType)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">false</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">super</span>.isVariableDeclarationRequired(expr,b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Override<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">protected</span>&nbsp;String&nbsp;getVarName(Object&nbsp;ex,&nbsp;IAppendable&nbsp;appendable)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(ex&nbsp;<span class="keyword">instanceof</span>&nbsp;JvmGenericType)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="string">"this"</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">super</span>.getVarName(ex,&nbsp;appendable);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;DomainmodelIdentifiableSimpleNameProvider&nbsp;<span class="keyword">extends</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;IdentifiableSimpleNameProvider&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">dispatch</span>&nbsp;getSimpleName(JvmType&nbsp;element)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="string">"this"</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;<span class="keyword">dispatch</span>&nbsp;getSimpleName(JvmIdentifiableElement&nbsp;element)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">super</span>.getSimpleName(element);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="xbaseExpressions_6"></a>
<h3>Using the Xbase Interpreter</h3>
<p>
Sometimes it is more convenient to interpret a model that uses Xbase than to generate code from it.  
Xbase ships with the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter" >XbaseInterpreter</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java" title="View Source Code" >(src)</a> which makes this
rather easy.
</p>
<p>
An interpreter is essentially an external visitor, that recursively processes a model based on the model
element&apos;s types. By now you should be aware that polymorphic dispatch is exactly the technology needed
here. In the <a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter" >XbaseInterpreter</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java" title="View Source Code" >(src)</a>, the dispatch method
is called <em>_evaluate&lt;ElementTypeWithoutX&gt;</em> and takes two parameters, e.g. 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">protected</span>&nbsp;Object&nbsp;_evaluateBlockExpression(XBlockExpression&nbsp;literal,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IEvaluationContext&nbsp;context,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CancelIndicator&nbsp;indicator)<br/>
</p>
</div>
</div>
</p>
<p>
The <a class="jdoc" href="http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/expressions/IEvaluationContext.html" title="View JavaDoc"><abbr title="org.eclipse.core.expressions.IEvaluationContext" >IEvaluationContext</abbr></a> keeps the state of the running application,
i.e. the local variables and their values. Additionally, it can be <em>fork</em>ed, thus allowing to shadow the 
elements of the original context. Here is an example code snippet how to call the
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.0.0/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter" >XbaseInterpreter</abbr></a> <a class="srcLink" href="https://github.com/svenefftinge/Xtext-2.0-released-source-code/tree/master/plugins/org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/interpreter/impl/XbaseInterpreter.java" title="View Source Code" >(src)</a>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
@Inject&nbsp;<span class="keyword">private</span>&nbsp;XbaseInterpreter&nbsp;xbaseInterpreter;<br/>
<br/>
@Inject&nbsp;<span class="keyword">private</span>&nbsp;Provider&lt;IEvaluationContext&gt;&nbsp;contextProvider;<br/>
<br/>
...<br/>
<span class="keyword">public</span>&nbsp;Object&nbsp;evaluate(XExpression&nbsp;expression,&nbsp;Object&nbsp;thisElement)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;IEvaluationContext&nbsp;evaluationContext&nbsp;=&nbsp;contextProvider.get();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;evaluationContext.newValue(XbaseScopeProvider.THIS,&nbsp;thisElement);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;IEvaluationResult&nbsp;result&nbsp;=&nbsp;xbaseInterpreter.evaluate(expression,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evaluationContext,&nbsp;CancelIndicator.NullImpl);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(result.getException()&nbsp;!=&nbsp;<span class="keyword">null</span>)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;handle&nbsp;exception<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;result.getResult();<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="xbaseLanguageRef_Introduction"></a>
<h2>Xbase Language Reference</h2>
<p>
This document describes the expression language library Xbase. Xbase is a partial programming language implemented in Xtext and is meant to be embedded and extended
within other programming languages and domain-specific languages (DSL) written in Xtext. Xtext is a highly extendable language development framework 
covering all aspects of language infrastructure such as parsers, linkers, compilers, interpreters and even full-blown IDE support based on Eclipse.  
</p>
<p>
Developing DSLs has become incredibly easy with Xtext. Structural languages which introduce new coarse-grained concepts, such as services, entities, value objects or 
state-machines can be developed in minutes. However, software systems do not consist of structures solely. At some point a system needs to have some behavior, 
which is usually specified using so called <em>expressions</em>. Expressions are the heart of every programming language and are not easy to get right.
On the other hand, expressions are well understood and many programming languages share a common set
and understanding of expressions.
That is why most people do not add support for expressions in their DSL, but try to solve this differently. The most often used workaround is to define only the structural information in the DSL 
and add behavior by modifying or extending the generated code. It is not only unpleasant to write, read and maintain information which closely belongs together in two different places, abstraction levels 
and languages. Also, modifying the generated source code comes with a lot of additional problems. But as of today this is the preferred solution since adding support for expressions (and
a corresponding execution environment) for your language is hard - even with Xtext.
</p>
<p>
Xbase serves as a language library providing a common expression language bound to the Java platform (i.e. Java Virtual Machine). It consists
of an Xtext grammar, as well as 
reusable and adaptable implementations for the different aspects of a language infrastructure such as an AST structure, a compiler, an interpreter, a linker, and a static analyzer.
In addition it comes with implementations to integrate the expression language within an Xtext-based Eclipse IDE. Default implementations for aspects like content assistance, syntax coloring, 
hovering, folding and navigation can be easily integrated and reused within any Xtext based language. 
</p>
<p>
Conceptually and syntactically, Xbase is very close to Java statements and expressions, but with a few differences:
<ul>
	<li>
		Runs on the JVM
	</li>
	<li>
		No checked exceptions
	</li>
	<li>
		Object-oriented
	</li>
	<li>
		Everything is an expression, there are no statements
	</li>
	<li>
		Closures
	</li>
	<li>
		Type inference
	</li>
	<li>
		Properties
	</li>
	<li>
		Simple operator overloading
	</li>
	<li>
		Powerful switch expressions
	</li>
</ul>

</p>
<a name="xbaseLanguageRef_Syntax"></a>
<h2>Lexical Syntax</h2>
<p>
Xbase comes with a small set of lexer rules, which can be overridden and hence changed by users. However the default implementation is carefully 
chosen and it is recommended to stick with the lexical syntax described in the following.
</p>
<a name="Xbase_Syntax_Identifiers"></a>
<h3>Identifiers</h3>
<p>
Identifiers are used to name all constructs, such as types, methods and variables. Xbase uses the default
Identifier-Syntax from Xtext - compared to Java, they are slightly simplified to match the common cases
while having less ambiguities. They start with a letter <em>a</em>-<em>z</em>, <em>A</em>-<em>Z</em> or an underscore followed
by more of these characters or a digit <em>0</em>-<em>9</em>. 
</p>
<a name="Xbase_Syntax_EscapedIdentifiers"></a>
<h3>Escaped Identifiers</h3>
<p>
Identifiers may not have the same spelling as any reserved keyword. 
However, identifiers starting with a <span class="inlinecode">^</span> are so called escaped identifiers. Escaped identifiers are used in cases when there is a 
conflict with a reserved keyword. Imagine you have introduced a keyword <span class="inlinecode">service</span> in your language but want to call a Java property <em>service</em> at some point. 
In such cases you use an escaped identifier <span class="inlinecode">^service</span> to reference the Java property.
</p>
<a name="Xbase_Syntax_EscapedIdentifiers_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">terminal</span>&nbsp;ID:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;^&apos;</span>?&nbsp;(<span class="string">&apos;a&apos;</span>..<span class="string">&apos;z&apos;</span>|<span class="string">&apos;A&apos;</span>..<span class="string">&apos;Z&apos;</span>|<span class="string">&apos;_&apos;</span>)&nbsp;(<span class="string">&apos;a&apos;</span>..<span class="string">&apos;z&apos;</span>|<span class="string">&apos;A&apos;</span>..<span class="string">&apos;Z&apos;</span>|<span class="string">&apos;_&apos;</span>|<span class="string">&apos;0&apos;</span>..<span class="string">&apos;9&apos;</span>)*<br/>
;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Syntax_EscapedIdentifiers_3"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">Foo</span>
	</li>
	<li>
		<span class="inlinecode">Foo42</span>
	</li>
	<li>
		<span class="inlinecode">FOO</span>
	</li>
	<li>
		<span class="inlinecode">_42</span>
	</li>
	<li>
		<span class="inlinecode">_foo</span>
	</li>
	<li>
		<span class="inlinecode">^extends</span>
	</li>
</ul>
</p>
<a name="Xbase_Syntax_StringLiteral"></a>
<h3>String Literals</h3>
<p>
String literals can either use single quotes (&apos;) or double quotes (") as their terminals. When using double quotes all literals allowed by Java string literals are
supported. In addition new line characters are allowed, that is in Xbase all string literals can span multiple lines. When using single quotes the only difference
is that single quotes within the literal have to be escaped and double quotes do not.
</p>
<p>
See <a href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.10.5">§ 3.10.5 String Literals</a>
</p>
<p>
In contrast to Java, equal string literals within the same class do not neccessarily refer to the same instance at runtime.
</p>
<a name="Xbase_Syntax_StringLiteral_4"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="comment">//TODO<br/>
</span>
</p>
</div>
</div>
</p>
<a name="Xbase_Syntax_StringLiteral_5"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="string">&apos;Foo&nbsp;Bar&nbsp;Baz&apos;</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="string">"Foo&nbsp;Bar&nbsp;Baz"</span></span>
	</li>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="string">"&nbsp;the&nbsp;quick&nbsp;brown&nbsp;fox&nbsp;<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jumps&nbsp;over&nbsp;the&nbsp;lazy&nbsp;dog."</span>
		</p>
		</div>
		</div>
	</li>
	<li>
		<span class="inlinecode"><span class="string">&apos;Escapes&nbsp;:&nbsp;\&apos;&nbsp;&apos;</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="string">"Escapes&nbsp;:&nbsp;\"&nbsp;"</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Syntax_IntegerLiteral"></a>
<h3>Integer Literals</h3>
<p>
Integer literals consist of one or more digits. 
Only decimal literals are supported and they always result in a value of type <span class="inlinecode">java.lang.Integer</span> 
(it might result in native type <span class="inlinecode">int</span> when translated to Java, see <a href="199g-xbase-language-reference-types.html" title="Go to &quot;Types&quot;">Types</a>).
The compiler makes sure that only numbers between 0 and <em>Integer.MAX</em> (0x7fffffff) are used.
</p>
<p>
There is no negative integer literal, instead the expression <span class="inlinecode">-23</span> is parsed as the prefix operator <span class="inlinecode">-</span> applied to an integer literal.
</p>
<a name="Xbase_Syntax_IntegerLiteral_3"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">terminal</span>&nbsp;INT&nbsp;<span class="keyword">returns</span>&nbsp;ecore::EInt:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;0&apos;</span>..<span class="string">&apos;9&apos;</span>)+<br/>
;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Syntax_Comments"></a>
<h4>Comments</h4>
<p>
Xbase comes with two different kinds of comments: Single-line comments and multi-line comments.
The syntax is the same as the one known from Java (see <a href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.7">§ 3.7 Comments</a>).
</p>
<a name="Xbase_Syntax_IntegerLiteral_5"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">terminal</span>&nbsp;ML_COMMENT&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;/*&apos;</span>&nbsp;-&gt;&nbsp;<span class="string">&apos;*/&apos;</span><br/>
;<br/>
<span class="keyword">terminal</span>&nbsp;SL_COMMENT&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;//&apos;</span>&nbsp;!(<span class="string">&apos;\n&apos;</span>|<span class="string">&apos;\r&apos;</span>)*&nbsp;(<span class="string">&apos;\r&apos;</span>?&nbsp;<span class="string">&apos;\n&apos;</span>)?<br/>
;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Syntax_Whitespace"></a>
<h3>White Space</h3>
<p>
The white space characters <span class="inlinecode"><span class="string">&apos;&nbsp;&apos;</span></span>, <span class="inlinecode"><span class="string">&apos;\t&apos;</span></span>, <span class="inlinecode"><span class="string">&apos;\n&apos;</span></span>, and <span class="inlinecode"><span class="string">&apos;\r</span></span> are allowed to occur anywhere between the other syntactic elements. 
</p>
<a name="Xbase_Syntax_Keywords"></a>
<h3>Reserved Keywords</h3>
<p>
The following list of words are reserved keywords, thus reducing the set of possible identifiers:
<ol>
	<li>
		<span class="inlinecode"><span class="keyword">extends</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">super</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">instanceof</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">as</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">new</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">null</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">false</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">true</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">val</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">var</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">if</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">else</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">switch</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">case</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">default</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">do</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">while</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">for</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">typeof</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">throw</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">try</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">catch</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">finally</span></span>
	</li>
</ol>
</p>
<p>
However, in case some of the keywords have to be used as identifiers, the escape character for <a href="199f-xbase-language-reference-syntax.html#Xbase_Syntax_EscapedIdentifiers" title="Go to &quot;Escaped Identifiers&quot;">identifiers</a> comes in handy. 
</p>
<a name="xbaseLanguageRef_Types"></a>
<h2>Types</h2>
<p>
Basically all kinds of JVM types are available and referable. 
</p>
<a name="Xbase_Types_Arrays"></a>
<h3>Arrays</h3>
<p>
Arrays cannot be declared explicitly,
but they can be passed around and if needed are transparently converted to a List of the compound type.
</p>
<p>
In other words, the return type of a Java method that returns an array of ints (<em>int[]</em>) can be directly assigned to 
a variable of type <em>java.util.List&lt;java.lang.Integer&gt;</em> (in short <em>List&lt;Integer&gt;</em>). Due to type inference
you can also defer the conversion. The conversion is bi-directional so any method, that takes an array as argument can be invoked with a <em>List</em>
instead.
</p>
<a name="Xbase_Types_TypeReferences"></a>
<h3>Simple Type References</h3>
<p>
A simple type reference only consists of a <em>qualified name</em>. A qualified name is a name made up of identifiers which are separated by a dot 
(like in Java).
</p>
<a name="Xbase_Types_TypeReferences_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
QualifiedName:<br/>
&nbsp;&nbsp;ID&nbsp;(<span class="string">&apos;.&apos;</span>&nbsp;ID)*<br/>
;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
There is no parser rule for a simple type reference, as it is expressed as a parameterized type references without parameters.
</p>
<a name="Xbase_Types_TypeReferences_3"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">java.lang.String</span>
	</li>
	<li>
		<span class="inlinecode">String</span>
	</li>
</ul>
</p>
<a name="Xbase_Types_FunctionTypes"></a>
<h3>Function Types</h3>
<p>
Xbase introduces <em>closures</em>, and therefore an additional function type signature. On the JVM-Level a closure (or more
generally any function object) is just an instance of one of the types in <span class="inlinecode">org.eclipse.xtext.xbase.lib.Function*</span>, 
depending on the number of arguments. However, as closures are a very important language feature, 
a special sugared syntax for function types has been introduced.  
So instead of writing <span class="inlinecode">Function1&lt;String,Boolean&gt;</span> one can write <span class="inlinecode">(String)=&gt;Boolean</span>.
</p>
<p>
Primitives cannot be used in function types.
</p>
<p>
For more information on closures see <a href="199h-xbase-language-reference-expressions.html#Xbase_Expressions_Closures" title="Go to &quot;Closures&quot;" >section Xbase_Expressions_Closures</a>.
</p>
<a name="Xbase_Types_FunctionTypes_4"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XFunctionTypeRef:<br/>
&nbsp;&nbsp;(<span class="string">&apos;(&apos;</span>JvmTypeReference&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;JvmTypeReference)*<span class="string">&apos;)&apos;</span>)?&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;=&gt;&apos;</span>&nbsp;JvmTypeReference;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Types_FunctionTypes_5"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">=&gt;Boolean&nbsp;<span class="comment">//&nbsp;predicate&nbsp;without&nbsp;parameters</span></span>
	</li>
	<li>
		<span class="inlinecode">(String)=&gt;Boolean&nbsp;<span class="comment">//&nbsp;One&nbsp;argument&nbsp;predicate</span></span>
	</li>
	<li>
		<span class="inlinecode">(Mutable)=&gt;Void&nbsp;<span class="comment">//&nbsp;A&nbsp;method&nbsp;doing&nbsp;side&nbsp;effects&nbsp;only&nbsp;-&nbsp;returns&nbsp;null</span></span>
	</li>
	<li>
		<span class="inlinecode">(List&lt;String&gt;,&nbsp;Integer)=&gt;String</span>
	</li>
</ul>
</p>
<a name="Xbase_Types_ParameterizedTypeReference"></a>
<h3>Parameterized Type References</h3>
<p>
The general syntax for type references allows to take any number of type arguments. The semantics as well as the syntax is almost the same as in Java, so please 
refer to the third edition of the  <a href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java Language Specification</a>.
</p>
<p>
The only difference is that in Xbase a type reference can also be a function type. In the following the full syntax of type references is shown, including function types and
type arguments.
</p>
<a name="Xbase_Types_ParameterizedTypeReference_3"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
JvmTypeReference:<br/>
&nbsp;&nbsp;JvmParameterizedTypeReference&nbsp;|&nbsp;<br/>
&nbsp;&nbsp;XFunctionTypeRef;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
XFunctionTypeRef:<br/>
&nbsp;&nbsp;(<span class="string">&apos;(&apos;</span>&nbsp;JvmTypeReference&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;JvmTypeReference)*&nbsp;<span class="string">&apos;)&apos;</span>)?&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;=&gt;&apos;</span>&nbsp;JvmTypeReference;<br/>
<br/>
JvmParameterizedTypeReference:<br/>
&nbsp;&nbsp;type=QualifiedName&nbsp;(<span class="string">&apos;&lt;&apos;</span>&nbsp;JvmTypeArgument&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;JvmTypeArgument)*&nbsp;<span class="string">&apos;&gt;&apos;</span>)?;<br/>
<br/>
JvmTypeArgument:<br/>
&nbsp;&nbsp;JvmReferenceTypeArgument&nbsp;|&nbsp;<br/>
&nbsp;&nbsp;JvmWildcardTypeArgument;<br/>
&nbsp;&nbsp;<br/>
JvmReferenceTypeArgument&nbsp;:<br/>
&nbsp;&nbsp;JvmTypeReference;<br/>
<br/>
JvmWildcardTypeArgument:<br/>
&nbsp;&nbsp;<span class="string">&apos;?&apos;</span>&nbsp;(JvmUpperBound&nbsp;|&nbsp;JvmLowerBound)?;<br/>
<br/>
JvmLowerBound&nbsp;:<br/>
&nbsp;<span class="string">&apos;super&apos;</span>&nbsp;JvmTypeReference;<br/>
<br/>
JvmUpperBound&nbsp;:&nbsp;<br/>
&nbsp;<span class="string">&apos;extends&apos;</span>&nbsp;JvmTypeReference;<br/>
<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Types_ParameterizedTypeReference_4"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">String</span>
	</li>
	<li>
		<span class="inlinecode">java.lang.String</span>
	</li>
	<li>
		<span class="inlinecode">List&lt;?&gt;</span>
	</li>
	<li>
		<span class="inlinecode">List&lt;?&nbsp;extends&nbsp;Comparable&lt;?&nbsp;extends&nbsp;FooBar&gt;</span>
	</li>
	<li>
		<span class="inlinecode">List&lt;?&nbsp;super&nbsp;MyLowerBound&gt;</span>
	</li>
	<li>
		<span class="inlinecode">List&lt;?&nbsp;extends&nbsp;=&gt;Boolean&gt;</span>
	</li>
</ul>
</p>
<a name="Xbase_Types_Primitives"></a>
<h3>Primitives</h3>
<p>
Xbase supports all Java primitives. The conformance rules (e.g. boxing unboxing) are also exactly like defined
in the Java Language Specification.
</p>
<a name="Xbase_Types_ConformanceRules"></a>
<h3>Conformance and Conversion</h3>
<p>
Conformance is used in order to find out whether some expression can be used in a certain situation. For instance when assigning a value to a variable, 
the type of the right hand expression needs to conform to the type of the variable.
</p>
<p>
As Xbase implements the unchanegd type system of Java it also fully supports the conformance rules defined
in <a href="http://java.sun.com/docs/books/jls/third_edition/html/conversions.html">The Java Language Specification</a>.
</p>
<a name="Xbase_Types_CommonSuperType"></a>
<h3>Common Super Type</h3>
<p>
Because of type inference Xbase sometimes needs to compute the most common super type of a given set
of types. 
</p>
<p>
For a set <em>[T1,T2,...Tn]</em> of types the common super type is computed by using the linear type inheritance sequence of <em>T1</em> and is iterated until one type
conforms to each <em>T2,..,Tn</em>. The linear type inheritance sequence of <em>T1</em> is computed by ordering all types which are part if the type hierarchy of <em>T1</em>
by their specificity. A type <em>T1</em> is considered more specific than <em>T2</em> if <em>T1</em> is a subtype of <em>T2</em>. Any types with equal specificity will be sorted by
the maximal distance to the originating subtype. <em>CharSequence</em> has distance 2 to <em>StringBuilder</em> because
the supertype <em>AbstractStringBuilder</em> implements the interface, too. Even if <em>StringBuilder</em> implements
<em>CharSequence</em> directly, the interface gets distance 2 in the ordering because it is not the most general class
in the type hierarchy that implements the interface. If the distances for two classes are the same in
the hierarchy, their qualified name is used as the compare-key to ensure deterministic results. 
</p>
<a name="xbaseLanguageRef_Expressions"></a>
<h2>Expressions</h2>
<p>
Expressions are the main language constructs which are used to express behavior and computation of values. The concept of 
statements is not supported, but instead powerful expressions are used to handle situations in which the imperative nature of statements would
be helpful, too. An 
expression always results in a value (might be the value &apos;null&apos; though). In addition every resolved expressions is
of a static type.
</p>
<a name="Xbase_Expressions_Literals"></a>
<h3>Literals</h3>
<p>
A literal denotes a fixed unchangeable value. Literals for string, integers, booleans,
null and Java types are supported.
</p>
<a name="Xbase_Expressions_StringLiterals"></a>
<h4>String Literals</h4>
<p>
A string literal as syntactically defined in <a href="199f-xbase-language-reference-syntax.html#Xbase_Syntax_StringLiteral" title="Go to &quot;String Literals&quot;" >section Xbase_Syntax_StringLiteral</a> is a valid expression and returns an instance of <span class="inlinecode">java.lang.String</span> of the given value.
</p>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="string">&apos;Hello&nbsp;World&nbsp;!&apos;</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="string">"Hello&nbsp;World&nbsp;!"</span></span>
	</li>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="string">"Hello&nbsp;<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;World&nbsp;!"</span><br/>
		</p>
		</div>
		</div>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_IntegerLiterals"></a>
<h4>Integer Literals</h4>
<p>
An integer literal as defined in <a href="199f-xbase-language-reference-syntax.html#Xbase_Syntax_IntegerLiteral" title="Go to &quot;Integer Literals&quot;" >section Xbase_Syntax_IntegerLiteral</a> creates an <span class="inlinecode">int</span>.
There is no signed int. If you put a minus operator in front of an int literal it is taken as a UnaryOperator
with one argument (the positive int literal).
</p>
<p>
<ul>
	<li>
		<span class="inlinecode">42</span>
	</li>
	<li>
		<span class="inlinecode">234254</span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_BooleanLiteral"></a>
<h4>Boolean Literals</h4>
<p>
There are two boolean literals, <span class="inlinecode">true</span> and <span class="inlinecode">false</span> which correspond to their Java counterpart of type <em>boolean</em>. 
</p>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">true</span></span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">false</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_NullLiteral"></a>
<h4>Null Literal</h4>
<p>
The null pointer literal is, like in Java, <span class="inlinecode">null</span>. 
It is a member of any reference type.
</p>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">null</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_TypeLiteral"></a>
<h4>Type Literals</h4>
<p>
Type literals are specified using the keyword <em>typeof</em> :
</p>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">typeof</span>(java.lang.String)</span> which yields java.lang.String.class
	</li>
</ul>
</p>
<a name="Xbase_Expressions_TypeCasts"></a>
<h3>Type Casts</h3>
<p>
Type cast behave like casts in Java, but have a slightly more readable syntax.
Type casts bind stronger than any other operator but weaker than feature calls.
</p>
<p>
The conformance rules for casts are defined in the <a href="http://java.sun.com/docs/books/jls/third_edition/html/conversions.html#5.5">Java Language Specification</a>.
</p>
<a name="Xbase_Expressions_TypeCasts_3"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XCastedExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;<span class="string">&apos;as&apos;</span>&nbsp;JvmTypeReference;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_TypeCasts_4"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">my.foo&nbsp;<span class="keyword">as</span>&nbsp;MyType</span>
	</li>
	<li>
		<span class="inlinecode">(1&nbsp;+&nbsp;3&nbsp;*&nbsp;5&nbsp;*&nbsp;(-&nbsp;23))&nbsp;<span class="keyword">as</span>&nbsp;BigInteger</span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_Operators"></a>
<h3>Infix Operators / Operator Overloading</h3>
<p>
There are a couple of common predefined infix operators. In contrast to Java, the operators are not limited
to operations on certain types. Instead an operator-to-method mapping allows users to redefine the 
operators for any type just by implementing the corresponding method signature.
The following defines the operators and the corresponding Java method signatures / expressions.
</p>
<p>
<table>
<tr>
<td>
<span class="inlinecode">e1&nbsp;+=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_add(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;||&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_or(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&amp;&amp;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_and(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;==&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_equals(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;!=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_notEquals(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_lessThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_greaterThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&lt;=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_lessEqualsThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;&gt;=&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_greaterEqualsThan(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-&gt;&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_mappedTo(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;..&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_upTo(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;+&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_plus(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;-&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_minus(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;*&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_multiply(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;/&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_divide(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;%&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_modulo(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">e1&nbsp;**&nbsp;e2</span>
</td>
<td>
<span class="inlinecode">e1._operator_power(e2)</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">!&nbsp;e1</span>
</td>
<td>
<span class="inlinecode">e1._operator_not()</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">-&nbsp;e1</span>
</td>
<td>
<span class="inlinecode">e1._operator_minus()</span>
</td>
</tr>
<tr>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
<td>
<span class="inlinecode">&nbsp;</span>
</td>
</tr>
</table>

		
The table above also defines the operator precedence in ascending order. The blank lines separate precedence levels. 
The assignment operator <span class="inlinecode">+=</span> is right-to-left associative in the same way as the plain assignment
operator <span class="inlinecode">=</span> is. That is a = b = c is executed as a = (b = c), all other
operators are left-to-right associative. Parenthesis can be used to adjust the default precedence and associativity. 
</p>
<a name="Xbase_Expressions_Operators_3"></a>
<h4>Short-Circuit Boolean Operators</h4>
<p>
If the operators <span class="inlinecode">||</span> and <span class="inlinecode">&amp;&amp;</span> are used in a context where the left hand operand is of type boolean, the operation is evaluated
in short circuit mode, which means that the right hand operand might not be evaluated at all in the following cases: 
<ol>
	<li>
		in the case of <span class="inlinecode">||</span> the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode"><span class="keyword">true</span></span>.
	</li>
	<li>
		in the case of <span class="inlinecode">&amp;&amp;</span> the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode"><span class="keyword">false</span></span>.
	</li>
</ol>
</p>
<a name="Xbase_Expressions_Operators_4"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">myList&nbsp;+=&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">x&nbsp;&gt;&nbsp;23&nbsp;&amp;&amp;&nbsp;y&nbsp;&lt;&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">x&nbsp;&amp;&amp;&nbsp;y&nbsp;||&nbsp;z</span>
	</li>
	<li>
		<span class="inlinecode">1&nbsp;+&nbsp;3&nbsp;*&nbsp;5&nbsp;*&nbsp;(-&nbsp;23)</span>
	</li>
	<li>
		<span class="inlinecode">!(x)</span>
	</li>
	<li>
		<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>
	</li>
	<li>
		<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_PropertyAssignment"></a>
<h4>Assignments</h4>
<p>
<a href="199h-xbase-language-reference-expressions.html#Xbase_Expressions_VariableDeclaration" title="Go to &quot;Variable Declarations&quot;">Local variables</a> can be reassigned using the <span class="inlinecode">=</span> operator. Also properties can be set using 
that operator:
Given the expression 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty&nbsp;=&nbsp;<span class="string">"foo"</span><br/>
</p>
</div>
</div>
</p>
<p>
The compiler first looks up whether there is an accessible Java Field called <span class="inlinecode">myProperty</span> on the type of <span class="inlinecode">myObj</span>. If there is one it translates to
the following Java expression :
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty&nbsp;=&nbsp;<span class="string">"foo"</span>;<br/>
</p>
</div>
</div>
</p>
<p>
Remember in Xbase everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
Java expression, which is the assigned value.
</p>
<p>
If there is no accessible field on the left operand&apos;s type, a method called <span class="inlinecode">setMyProperty(OneArg)</span> (JavaBeans
setter method) is looked up. It has to take one argument of the type (or a super type) of the right hand operand. The return value will be whatever the 
setter method returns (which usually is <span class="inlinecode">null</span>). 
As a result the compiler translates to :
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myObj.setMyProperty(<span class="string">"foo"</span>)<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_FeatureCalls"></a>
<h3>Feature Calls</h3>
<p>
A feature call is used to invoke members of objects, such as fields and methods, but also can refer to local variables and parameters, 
which are made available for the current expression&apos;s scope. 
</p>
<a name="Xbase_Expressions_FeatureCalls_2"></a>
<h4>Syntax</h4>
<p>
The following snippet is a simplification of the real Xtext rules, which cover more than the concrete syntax.
<div class="literallayout">
<div class="incode">
<p class="code">
FeatureCall&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ID&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;(<span class="string">&apos;.&apos;</span>&nbsp;ID&nbsp;(<span class="string">&apos;(&apos;</span>&nbsp;Expression&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;Expression)*&nbsp;<span class="string">&apos;)&apos;</span>)?)*<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_PropertyAccess"></a>
<h4>Property Access</h4>
<p>
Feature calls are directly translated to their Java equivalent with the exception, that for calls to properties an equivalent rule as 
described in <a href="199h-xbase-language-reference-expressions.html#Xbase_Expressions_PropertyAssignment" title="Go to &quot;Assignments&quot;" >section Xbase_Expressions_PropertyAssignment</a> applies. 
That is, for the following expression
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty<br/>
</p>
</div>
</div>
</p>
<p>
the compiler first looks for an accessible field in the type of <span class="inlinecode">myObj</span>. If no such field exists it looks for a method called <span class="inlinecode">myProperty()</span> before it looks 
for the getter methods <span class="inlinecode">getMyProperty()</span>. If none of these members can be found the expression is unbound and a compiliation error is thrown.
</p>
<a name="Xbase_Expressions_ImplicitThis"></a>
<h4>Implicit 'this' variable</h4>
<p>
If the current scope contains a variable named <span class="inlinecode"><span class="keyword">this</span></span>, the compiler will make all its members available to the scope. 
That is if 
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">this</span>.myProperty<br/>
</p>
</div>
</div>

is a valid expression
<div class="literallayout">
<div class="incode">
<p class="code">
myProperty<br/>
</p>
</div>
</div>

is valid as well and is equivalent, as long as there is no local variable &apos;myProperty&apos; on the scope,
which would have higher precedence.
</p>
<a name="Xbase_Expressions_NullSafeFeatureCalls"></a>
<h4>Null-Safe Feature Call</h4>
<p>
Checking for null references can make code very unreadable. In many situations it is ok for an expression to return null if a receiver was null.
Xbase supports the safe navigation operator <span class="inlinecode">?.</span> to make such code more readable.
</p>
<p>
Instead of writing 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">if</span>&nbsp;(&nbsp;myRef&nbsp;!=&nbsp;<span class="keyword">null</span>&nbsp;)&nbsp;myRef.doStuff()<br/>
</p>
</div>
</div>
</p>
<p>
one can write
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myRef?.doStuff()<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_ConstructorCall"></a>
<h3>Constructor Call</h3>
<p>
Construction of objects is done by invoking Java constructors. The syntax is exactly as in Java.
</p>
<a name="Xbase_Expressions_ConstructorCall_2"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">new</span>&nbsp;String()<br/>
		</p>
		</div>
		</div>
		
	</li>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">new</span>&nbsp;java.util.ArrayList&lt;java.math.BigDecimal&gt;()<br/>
		</p>
		</div>
		</div>
		
	</li>
</ul>
</p>
<a name="Xbase_Expressions_ConstructorCall_3"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XConstructorCall:<br/>
&nbsp;&nbsp;<span class="string">&apos;new&apos;</span>&nbsp;QualifiedName&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;&lt;&apos;</span>&nbsp;JvmTypeArgument&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;JvmTypeArgument)*&nbsp;<span class="string">&apos;&gt;&apos;</span>)?&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;(&apos;</span>(XExpression&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;XExpression)*)?<span class="string">&apos;)&apos;</span>)?;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_Closures"></a>
<h3>Closures</h3>
<p>
A closure is a literal that defines an anonymous function. A closure also captures the current scope,
so that any final variables and parameters visible at construction time can be referred to in the closure&apos;s expression. 
</p>
<a name="Xbase_Expressions_Closures_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XClosure:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;[&apos;</span>&nbsp;(&nbsp;JvmFormalParameter&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;JvmFormalParameter)*&nbsp;)?&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;|&apos;</span>&nbsp;XExpression&nbsp;<span class="string">&apos;]&apos;</span>;<br/>
</p>
</div>
</div>
</p>
<p>
The surrounding square brackets are optional if the closure is the single argument of a method invocation.
That is you can write
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myList.find(e|e.name==<span class="keyword">null</span>)<br/>
</p>
</div>
</div>
</p>
<p>
instead of
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myList.find([e|e.name==<span class="keyword">null</span>])<br/>
</p>
</div>
</div>
</p>
<p>
But in all other cases the square brackets are mandatory:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">val</span>&nbsp;func&nbsp;=&nbsp;[String&nbsp;s|&nbsp;s.length&gt;3]<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_ClosuresTypeInference"></a>
<h4>Typing</h4>
<p>
Closures are expressions which produce function objects. The type is a <a href="199g-xbase-language-reference-types.html#Xbase_Types_FunctionTypes" title="Go to &quot;Function Types&quot;">function type</a>, consisting of the types of the 
parameters as well as the return type. The return type is never specified explicitly but is always inferred from the expression. 
The parameter types can be inferred if the closure is used in a context where this is possible.
</p>
<p>
For instance, given the following Java method signature:
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;T&nbsp;&lt;T&gt;getFirst(List&lt;T&gt;&nbsp;list,&nbsp;Function0&lt;T,Boolean&gt;&nbsp;predicate)&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
the type of the parameter can be inferred. Which allows users to write:
<div class="literallayout">
<div class="incode">
<p class="code">
arrayList(&nbsp;<span class="string">"Foo"</span>,&nbsp;<span class="string">"Bar"</span>&nbsp;).findFirst(&nbsp;e&nbsp;|&nbsp;e&nbsp;==&nbsp;<span class="string">"Bar"</span>&nbsp;)<br/>
</p>
</div>
</div>

instead of 
<div class="literallayout">
<div class="incode">
<p class="code">
arrayList(&nbsp;<span class="string">"Foo"</span>,&nbsp;<span class="string">"Bar"</span>&nbsp;).findFirst(&nbsp;String&nbsp;e&nbsp;|&nbsp;e&nbsp;==&nbsp;<span class="string">"Bar"</span>&nbsp;)<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_FunctionMapping"></a>
<h4>Function Mapping</h4>
<p>
An Xbase closure is a Java object of one of the <em>Function</em> interfaces shipped with the runtime library of Xbase. There is an interface 
for each number of parameters (current maximum is six parameters). The names of the interfaces are 
<ul>
	<li>
		<em>Function0&lt;ReturnType&gt;</em> for zero parameters, 
	</li>
	<li>
		<em>Function1&lt;Param1Type, ReturnType&gt;</em> for one parameters, 
	</li>
	<li>
		<em>Function2&lt;Param1Type, Param2Type, ReturnType&gt;</em> for two parameters, 
	</li>
	<li>
		... 
	</li>
	<li>
		<em>Function6&lt;Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType&gt;</em> for six parameters, 
	</li>
</ul>
</p>
<p>
In order to allow seamless integration with existing Java libraries such as the JDK or Google Guava (formerly known as Google Collect) closures
are auto coerced to expected types if those types declare only one method (methods from java.lang.Object
don&apos;t count).
</p>
<p>
As a result given the method <span class="inlinecode">java.util.Collections.sort(List&lt;T&gt;,&nbsp;Comparator&lt;?&nbsp;super&nbsp;T&gt;)</span> is available
as an extension method, it can be invoked like this
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
newArrayList(&nbsp;<span class="string">&apos;aaa&apos;</span>,&nbsp;<span class="string">&apos;bb&apos;</span>,&nbsp;<span class="string">&apos;c&apos;</span>&nbsp;).sort(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e1,&nbsp;e2&nbsp;|&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;e1.length&nbsp;&gt;&nbsp;e2.length&nbsp;)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(&nbsp;e1.length&nbsp;&lt;&nbsp;e2.length&nbsp;)&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_Closures_5"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode">[&nbsp;|&nbsp;<span class="string">"foo"</span>&nbsp;]&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;closure&nbsp;without&nbsp;parameters</span></span>
	</li>
	<li>
		<span class="inlinecode">[&nbsp;String&nbsp;s&nbsp;|&nbsp;s.toUpperCase()&nbsp;]&nbsp;<span class="comment">//&nbsp;explicit&nbsp;argument&nbsp;type</span></span>
	</li>
	<li>
		<span class="inlinecode">[&nbsp;a,b,a&nbsp;|&nbsp;a+b+c&nbsp;]&nbsp;<span class="comment">//&nbsp;inferred&nbsp;argument&nbsp;types</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_IfExpression"></a>
<h3>If Expression</h3>
<p>
An if expression is used to choose two different values based on a predicate. While it has the syntax of Java&apos;s if statement it behaves  
like Java&apos;s ternary operator (<span class="inlinecode">predicate&nbsp;?&nbsp;thenPart&nbsp;:&nbsp;elsePart</span>), i.e. it is an expression that returns a value. Consequently, you can use 
if expressions deeply nested within expressions.
</p>
<a name="Xbase_Expressions_IfExpression_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XIfExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;if&apos;</span>&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;XExpression&nbsp;<span class="string">&apos;)&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XExpression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;else&apos;</span>&nbsp;XExpression)?;<br/>
</p>
</div>
</div>
</p>
<p>
An expression <span class="inlinecode"><span class="keyword">if</span>&nbsp;(p)&nbsp;e1&nbsp;<span class="keyword">else</span>&nbsp;e2</span> results in either the value <span class="inlinecode">e1</span> or <span class="inlinecode">e2</span> depending on whether the predicate <span class="inlinecode">p</span> 
evaluates to <span class="inlinecode"><span class="keyword">true</span></span> or <span class="inlinecode"><span class="keyword">false</span></span>. The else part is optional which is a shorthand for <span class="inlinecode"><span class="keyword">else</span>&nbsp;<span class="keyword">null</span></span>.
That means 
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">if</span>&nbsp;(foo)&nbsp;x&nbsp;<br/>
</p>
</div>
</div>
</p>
<p>
is the a short hand for
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">if</span>&nbsp;(foo)&nbsp;x&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">null</span><br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_IfTypeInference"></a>
<h4>Typing</h4>
<p>
The type of an if expression is calculated by the return types <span class="inlinecode">T1</span> and <span class="inlinecode">T2</span> of the two expression <span class="inlinecode">e1</span> and <span class="inlinecode">e2</span>.
It uses the rules defined in <a href="199g-xbase-language-reference-types.html#Xbase_Types_CommonSuperType" title="Go to &quot;Common Super Type&quot;" >section Xbase_Types_CommonSuperType</a>.
</p>
<a name="Xbase_Expressions_IfExpression_4"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<span class="inlinecode"><span class="keyword">if</span>&nbsp;(isFoo)&nbsp;<span class="keyword">this</span>&nbsp;<span class="keyword">else</span>&nbsp;that</span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">if</span>&nbsp;(isFoo)&nbsp;{&nbsp;<span class="keyword">this</span>&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;(thatFoo)&nbsp;{&nbsp;that&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{&nbsp;other&nbsp;}</span>
	</li>
	<li>
		<span class="inlinecode"><span class="keyword">if</span>&nbsp;(isFoo)&nbsp;<span class="keyword">this</span></span>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_SwitchExpression"></a>
<h3>Switch Expression</h3>
<p>
The switch expression is a bit different from Java&apos;s. First, there is no fall through which means only one case is evaluated at most.
Second, the use of switch is not limited to certain values but can be used for any object reference instead.
 
For a switch expression 
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">switch</span>&nbsp;e&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;e1&nbsp;:&nbsp;er1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;e2&nbsp;:&nbsp;er2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;en&nbsp;:&nbsp;ern<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;er<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
the main expression <span class="inlinecode">e</span> is evaluated first and then each case sequentially. If the switch expression
contains a variable declaration using the syntax known from <a href="199h-xbase-language-reference-expressions.html#Xbase_Expressions_ForLoop" title="Go to &quot;For Loop&quot;" >section Xbase_Expressions_ForLoop</a>, the value is bound to the given name.
Expressions of type <span class="inlinecode">java.lang.Boolean</span> or <span class="inlinecode">boolean</span> are not allowed in a switch expression.
</p>
<p>
The guard of each case clause is evaluated until the switch value equals the result of the case&apos;s guard expression or if the case&apos;s guard expression evaluates to <span class="inlinecode">true</span>.
Then the right hand expression of the case evaluated and the result is returned.
</p>
<p>
If none of the guards matches the default expression is evaluated an returned. If no default expression
is specified the expression evaluates to <span class="inlinecode"><span class="keyword">null</span></span>.
</p>
<p>
Example:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">switch</span>&nbsp;myString&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;myString.length&gt;5&nbsp;:&nbsp;<span class="string">&apos;a&nbsp;long&nbsp;string.&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;:&nbsp;<span class="string">&apos;It&apos;</span>s&nbsp;a&nbsp;foo.<span class="string">&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;&apos;</span>It<span class="string">&apos;s&nbsp;a&nbsp;short&nbsp;non-foo&nbsp;string.&apos;</span><br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_SwitchExpression_7"></a>
<h4>Type guards</h4>
<p>
In addition to the case guards one can add a so called <em>Type Guard</em> which is syntactically just a <a href="199g-xbase-language-reference-types.html#Xbase_Types_TypeReferences" title="Go to &quot;Simple Type References&quot;">type reference</a> preceding
the than optional case keyword. The compiler will use that type for the switch expression in subsequent expressions.
Example:
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">var</span>&nbsp;Object&nbsp;x&nbsp;=&nbsp;...;<br/>
<span class="keyword">switch</span>&nbsp;x&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;<span class="keyword">case</span>&nbsp;x.length()&gt;0&nbsp;:&nbsp;x.length()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;List&lt;?&gt;&nbsp;:&nbsp;x.size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;-1<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Only if the switch value passes a type guard, i.e. an instanceof operation returns <span class="inlinecode">true</span>, the case&apos;s guard expression is executed using the same semantics explained in
previously. 
If the switch expression contains an explicit declaration of a local variable or the expression references a local variable,
the type guard acts like a cast, that is all references to the switch value will be of the type specified in the type guard.
</p>
<a name="Xbase_Expressions_SwitchExpression_8"></a>
<h4>Typing</h4>
<p>
The return type of a switch expression is computed using the rules defined in <a href="199g-xbase-language-reference-types.html#Xbase_Types_CommonSuperType" title="Go to &quot;Common Super Type&quot;" >section Xbase_Types_CommonSuperType</a>. The set of types from which the common super type is 
computed corresponds to the types of each case&apos;s result expression. In case a switch expression&apos;s type is
computed using the expected type from the context, it is sufficient to return the expected type if all case branches types conform to the expected type.
</p>
<a name="Xbase_Expressions_SwitchExpression_9"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">switch</span>&nbsp;foo&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;Entity&nbsp;:&nbsp;foo.superType.name<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;Datatype&nbsp;:&nbsp;foo.name<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalStateException<br/>
		}<br/>
		</p>
		</div>
		</div>
		
	</li>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">switch</span>&nbsp;x&nbsp;:&nbsp;foo.bar.complicated(<span class="string">&apos;hello&apos;</span>,42)&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="string">"hello42"</span>&nbsp;:&nbsp;...<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;x.length&lt;2&nbsp;:&nbsp;...<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">default</span>&nbsp;:&nbsp;....<br/>
		}<br/>
		</p>
		</div>
		</div>
		
	</li>
</ul>
</p>
<a name="Xbase_Expressions_SwitchExpression_10"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XSwitchExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;switch&apos;</span>&nbsp;(ID&nbsp;<span class="string">&apos;:&apos;</span>)?&nbsp;XExpression&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XCasePart+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;default&apos;</span>&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;XExpression))?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;}&apos;</span>;<br/>
<br/>
XCasePart:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;JvmTypeReference?&nbsp;(<span class="string">&apos;case&apos;</span>&nbsp;XExpression)?&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;XExpression&nbsp;);<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_VariableDeclaration"></a>
<h3>Variable Declarations</h3>
<p>
Variable declarations are only allowed within <a href="199h-xbase-language-reference-expressions.html#Xbase_Expressions_Blocks" title="Go to &quot;Blocks&quot;">blocks</a>. They are visible in any subsequent expressions in
the block. Although overriding or shadowing variables from outer scopes is allowed, it is usually only
used to overload the variable name &apos;this&apos;, in order to subsequently access an object&apos;s features in an
unqualified manner.
</p>
<p>
A variable declaration starting with the keyword <span class="inlinecode"><span class="keyword">val</span></span> denotes a so called value, which is essentially a final (i.e. unsettable) variable. In rare cases, one
needs to update the value of a reference. In such situations the variable needs to be declared with the keyword <span class="inlinecode"><span class="keyword">var</span></span>, which stands for &apos;variable&apos;.
</p>
<p>
A typical example for using <span class="inlinecode"><span class="keyword">var</span></span> is a counter in a loop. 
<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;max&nbsp;=&nbsp;100<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;i&nbsp;=&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;(i&nbsp;&gt;&nbsp;max)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<span class="string">"Hi&nbsp;there!"</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Variables declared outside a closure using the <span class="inlinecode">var</span> keyword are not accessible from within a
closure.
</p>
<a name="Xbase_Expressions_VariableDeclaration_5"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XVariableDeclaration:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;val&apos;</span>&nbsp;|&nbsp;<span class="string">&apos;var&apos;</span>)&nbsp;JvmTypeReference?&nbsp;ID&nbsp;<span class="string">&apos;=&apos;</span>&nbsp;XExpression;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_VariableDeclaration_6"></a>
<h4>Typing</h4>
<p>
The return type of a variable declaration expression is always <span class="inlinecode">void</span>. 
The type of the variable itself can either be explicitly declared or be inferred from the right hand side expression.
Here is an example for an explicitly declared type:
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">var</span>&nbsp;List&lt;String&gt;&nbsp;msg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayList&lt;String&gt;();&nbsp;<br/>
</p>
</div>
</div>

In such cases, the right hand expression&apos;s type must <a href="199g-xbase-language-reference-types.html#Xbase_Types_ConformanceRules" title="Go to &quot;Conformance and Conversion&quot;">conform</a> to the type on the left hand side. 
</p>
<p>
Alternatively the type can be left out and will be inferred from the initialization expression:  
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">var</span>&nbsp;msg&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayList&lt;String&gt;();&nbsp;<span class="comment">//&nbsp;-&gt;&nbsp;type&nbsp;ArrayList&lt;String&gt;&nbsp;&nbsp;<br/>
</span>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_Blocks"></a>
<h3>Blocks</h3>
<p>
The block expression allows to have imperative code sequences. It consists of a sequence of expressions, and returns the value of the last expression.
The return type of a block is also the type of the last expression. Empty blocks return <span class="inlinecode">null</span>. 
<a href="199h-xbase-language-reference-expressions.html#Xbase_Expressions_VariableDeclaration" title="Go to &quot;Variable Declarations&quot;">Variable declarations</a> are only allowed within blocks and cannot be used as a block&apos;s last expression.
</p>
<p>
A block expression is surrounded by curly braces and contains at least one expression.
It can optionally be terminated by a semicolon.
</p>
<a name="Xbase_Expressions_Blocks_3"></a>
<h4>Examples</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(<span class="string">"foo"</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result<br/>
}<br/>
</p>
</div>
</div>

<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;x&nbsp;=&nbsp;greeting();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(x.equals(<span class="string">"Hello&nbsp;"</span>))&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x+<span class="string">"World!"</span>;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_Blocks_4"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XBlockExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(XExpressionInsideBlock&nbsp;<span class="string">&apos;;&apos;</span>?)*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;}&apos;</span>;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_ForLoop"></a>
<h3>For Loop</h3>
<p>
The for loop <span class="inlinecode"><span class="keyword">for</span>&nbsp;(T1&nbsp;variable&nbsp;:&nbsp;iterableOfT1)&nbsp;expression</span> is used to execute a certain expression for each element of an
array of an instance of <span class="inlinecode">java.lang.Iterable</span>.
The local <span class="inlinecode">variable</span> is final, hence canot be updated. 
</p>
<p>
The return type of a for loop is <span class="inlinecode"><span class="keyword">void</span></span>.
The type of the local variable can be left out. In that case it is inferred from the type of the array
or <span class="inlinecode">java.lang.Iterable</span> returned by the iterable expression.
</p>
<p>
<ul>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">for</span>&nbsp;(String&nbsp;s&nbsp;:&nbsp;myStrings)&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(s);<br/>
		}<br/>
		</p>
		</div>
		</div>
		
	</li>
	<li>
		
				<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">for</span>&nbsp;(s&nbsp;:&nbsp;myStrings)<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(s)<br/>
		</p>
		</div>
		</div>
		
	</li>
</ul>
</p>
<a name="Xbase_Expressions_ForLoop_4"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XForExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;for&apos;</span>&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;JvmFormalParameter&nbsp;<span class="string">&apos;:&apos;</span>&nbsp;XExpression&nbsp;<span class="string">&apos;)&apos;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XExpression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_WhileExpression"></a>
<h3>While Loop</h3>
<p>
A while loop <span class="inlinecode"><span class="keyword">while</span>&nbsp;(predicate)&nbsp;expression</span> is used to execute a certain expression unless the predicate is evaluated to <span class="inlinecode"><span class="keyword">false</span></span>.
The return type of a while loop is <span class="inlinecode"><span class="keyword">void</span></span>.
</p>
<a name="Xbase_Expressions_WhileExpression_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XWhileExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;while&apos;</span>&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;predicate=XExpression&nbsp;<span class="string">&apos;)&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=XExpression;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_WhileExpression_3"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">while</span>&nbsp;(<span class="keyword">true</span>)&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(<span class="string">"foo"</span>);<br/>
		}<br/>
		</p>
		</div>
		</div>
	</li>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">while</span>&nbsp;(&nbsp;(&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1&nbsp;)&nbsp;&lt;&nbsp;max&nbsp;)&nbsp;<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(&nbsp;<span class="string">"foo"</span>&nbsp;)<br/>
		</p>
		</div>
		</div>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_DoWhileExpression"></a>
<h3>Do-While Loop</h3>
<p>
A do-while loop <span class="inlinecode"><span class="keyword">do</span>&nbsp;expression&nbsp;<span class="keyword">while</span>&nbsp;(predicate)</span> is used to execute a certain expression unless the predicate is evaluated to <span class="inlinecode"><span class="keyword">false</span></span>.
The difference to the <a href="199h-xbase-language-reference-expressions.html#Xbase_Expressions_WhileExpression" title="Go to &quot;While Loop&quot;">while loop</a> is that the execution starts by executing the block once before evaluating the predicate for the first time.
The return type of a do-while loop is <span class="inlinecode"><span class="keyword">void</span></span>.
</p>
<a name="Xbase_Expressions_DoWhileExpression_2"></a>
<h4>Syntax</h4>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
XDoWhileExpression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;do&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=XExpression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;while&apos;</span>&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;predicate=XExpression&nbsp;<span class="string">&apos;)&apos;</span>;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_DoWhileExpression_3"></a>
<h4>Examples</h4>
<p>
<ul>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">do</span>&nbsp;{<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(<span class="string">"foo"</span>);<br/>
		}&nbsp;<span class="keyword">while</span>&nbsp;(<span class="keyword">true</span>)<br/>
		</p>
		</div>
		</div>
	</li>
	<li>
		<div class="literallayout">
		<div class="incode">
		<p class="code">
		<span class="keyword">do</span>&nbsp;doSideEffect(<span class="string">"foo"</span>)&nbsp;<span class="keyword">while</span>&nbsp;((i=i+1)&lt;max)<br/>
		</p>
		</div>
		</div>
	</li>
</ul>
</p>
<a name="Xbase_Expressions_Return"></a>
<h3>Return Expression</h3>
<p>
Although an explicit return is often not necessary, it is supported.
In a closure for instance a return expression is always implied if the expression itself is not of type
<span class="inlinecode"><span class="keyword">void</span></span>. Anyway you can make it explicit:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
listOfStrings.map(e|&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(e==<span class="keyword">null</span>)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="string">"NULL"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;e.toUpperCase<br/>
})&nbsp;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_Throw"></a>
<h3>Throwing Exceptions</h3>
<p>
Like in Java it is possible to throw <span class="inlinecode">java.lang.Throwable</span>. The syntax is exactly the same as in Java.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(myList.isEmpty)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;IllegalArgumentException(<span class="string">"the&nbsp;list&nbsp;must&nbsp;not&nbsp;be&nbsp;empty"</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...<br/>
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
</p>
</div>
</div>
</p>
<a name="Xbase_Expressions_TryCatch"></a>
<h3>Try, Catch, Finally</h3>
<p>
The try-catch-finally expression is used to handle exceptional situations.
You are not forced to declare checked exceptions, if you don&apos;t catch checked exceptions they are rethrown
in a wrapping runtime exception. 
Other than that the syntax again is like the one known from Java.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">try</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throw</span>&nbsp;<span class="keyword">new</span>&nbsp;RuntimeException()<br/>
}&nbsp;<span class="keyword">catch</span>&nbsp;(NullPointerException&nbsp;e)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;handle&nbsp;e<br/>
</span>}&nbsp;<span class="keyword">finally</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;do&nbsp;stuff<br/>
</span>}<br/>
</p>
</div>
</div>

</p>
<a name="xbaseLanguageRef_LibraryExtension"></a>
<h2>Extension Methods</h2>
<p>
Languages extending Xbase might want to contribute to the feature scope. Besides that one can of course
change the whole implementation as it seems fit there is a special hook, which can be used to add so
called extension methods to existing types. 
</p>
<p>
Xbase itself comes with a standard library of such extension methods adding support for various operators
for the common types, such as java.lang.String, java.util.List, etc.
</p>
<p>
These extension methods are declared in separate Java classes. There are various ways how extension methods
can be added. The simplest is, that the language designer predefines, which extension methods are available.
This means, that language users cannot add additional library functions using this mechanism.
</p>
<p>
Another alternative is to have them looked up by a certain naming convention. Also for more general languages
it is possible to let users add extension methods using imports or the like. This approach can be seen in the
language Xtend2, where extension methods are lexically imported through static imports and/or dependency
injection.
</p>
<p>
The precedence of extension methods is always lower than real member methods, that is you cannot override
member features. Also the extension members are not invoked polymorphic. If you have two extension methods
on the scope (<span class="inlinecode">foo(Object)</span> and <span class="inlinecode">foo(String)</span>) the expression <span class="inlinecode">(foo&nbsp;as&nbsp;Object).foo</span> would
bind and invoke <span class="inlinecode">foo(Object)</span>.
</p>
<a name="xbaseLanguageRef_LibraryExtension_6"></a>
<h3>Examples</h3>
<p>
<ul>
	<li>
		<span class="inlinecode">foo</span>
	</li>
	<li>
		<span class="inlinecode">my.foo</span>
	</li>
	<li>
		<span class="inlinecode">my.foo(x)</span>
	</li>
	<li>
		<span class="inlinecode">oh.my.foo(bar)</span>
	</li>
</ul>
</p>
</body>
</html>
